---
phase: 03-central-listener
plan: 04
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - listener/src/handlers/udp-receiver.ts
  - listener/src/middleware/rate-limit.ts
  - listener/src/server.ts
autonomous: true

must_haves:
  truths:
    - "UDP socket receives profiling data on configured port"
    - "Rate limiting prevents abuse from single IP addresses"
    - "UDP payloads are validated and stored same as HTTP"
    - "Server handles both HTTP and UDP simultaneously"
  artifacts:
    - path: "listener/src/handlers/udp-receiver.ts"
      provides: "UDP socket handler for profiling data"
      exports: ["startUdpServer", "stopUdpServer"]
    - path: "listener/src/middleware/rate-limit.ts"
      provides: "In-memory rate limiting per IP"
      exports: ["checkRateLimit", "RateLimitResult"]
  key_links:
    - from: "listener/src/handlers/udp-receiver.ts"
      to: "listener/src/database/queries.ts"
      via: "insertProfilingData prepared statement call"
      pattern: "insertProfilingData\\.run"
    - from: "listener/src/server.ts"
      to: "listener/src/handlers/udp-receiver.ts"
      via: "UDP server initialization"
      pattern: "startUdpServer"
---

<objective>
Add UDP receiver for high-throughput scenarios and basic rate limiting for abuse prevention.

Purpose: Complete LIST-01 (UDP support) and add basic protection per research recommendations. UDP provides fire-and-forget option for very high volume scenarios.
Output: Listener accepts data via both HTTP and UDP with rate limiting protection.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-central-listener/03-CONTEXT.md
@.planning/phases/03-central-listener/03-RESEARCH.md
@.planning/phases/03-central-listener/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting middleware</name>
  <files>
    listener/src/middleware/rate-limit.ts
  </files>
  <action>
Create listener/src/middleware/rate-limit.ts:

```typescript
interface RateLimitEntry {
  count: number;
  windowStart: number;
}

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: number;
}

// In-memory rate limit storage
// Key: IP address, Value: request counts per window
const rateLimits = new Map<string, RateLimitEntry>();

// Configuration (100 requests per minute per IP, per research recommendations)
const WINDOW_MS = 60 * 1000;  // 1 minute window
const MAX_REQUESTS = Number(Bun.env.BITVILLE_RATE_LIMIT) || 100;

// Cleanup interval (remove stale entries every 5 minutes)
let cleanupInterval: Timer | null = null;

/**
 * Check if request is within rate limit
 * @param ip Client IP address
 * @returns Rate limit result with remaining requests
 */
export function checkRateLimit(ip: string): RateLimitResult {
  const now = Date.now();
  const entry = rateLimits.get(ip);

  // No entry or expired window - start fresh
  if (!entry || now - entry.windowStart >= WINDOW_MS) {
    rateLimits.set(ip, { count: 1, windowStart: now });
    return {
      allowed: true,
      remaining: MAX_REQUESTS - 1,
      resetAt: now + WINDOW_MS,
    };
  }

  // Within window - check count
  if (entry.count >= MAX_REQUESTS) {
    return {
      allowed: false,
      remaining: 0,
      resetAt: entry.windowStart + WINDOW_MS,
    };
  }

  // Increment and allow
  entry.count++;
  return {
    allowed: true,
    remaining: MAX_REQUESTS - entry.count,
    resetAt: entry.windowStart + WINDOW_MS,
  };
}

/**
 * Get client IP from request
 * Handles X-Forwarded-For for proxied requests
 */
export function getClientIp(req: Request, server: { requestIP(req: Request): { address: string } | null }): string {
  // Check X-Forwarded-For header (trusted proxy scenario)
  const forwarded = req.headers.get("X-Forwarded-For");
  if (forwarded) {
    // Take first IP (original client)
    return forwarded.split(",")[0].trim();
  }

  // Use direct connection IP
  const ip = server.requestIP(req);
  return ip?.address || "unknown";
}

/**
 * Start periodic cleanup of stale rate limit entries
 */
export function startRateLimitCleanup(): void {
  if (cleanupInterval) return;

  cleanupInterval = setInterval(() => {
    const now = Date.now();
    let cleaned = 0;

    for (const [ip, entry] of rateLimits) {
      if (now - entry.windowStart >= WINDOW_MS * 2) {
        rateLimits.delete(ip);
        cleaned++;
      }
    }

    if (cleaned > 0) {
      console.log(`[RateLimit] Cleaned ${cleaned} stale entries`);
    }
  }, 5 * 60 * 1000);  // Every 5 minutes
}

/**
 * Stop cleanup interval
 */
export function stopRateLimitCleanup(): void {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
  }
}

/**
 * Get current rate limit stats
 */
export function getRateLimitStats(): { activeIps: number; maxRequests: number; windowMs: number } {
  return {
    activeIps: rateLimits.size,
    maxRequests: MAX_REQUESTS,
    windowMs: WINDOW_MS,
  };
}
```
  </action>
  <verify>
Create test that:
1. Calls checkRateLimit("1.2.3.4") 100 times
2. Verifies all return allowed: true
3. Calls once more, verifies allowed: false
4. Waits 61 seconds, calls again, verifies allowed: true (window reset)

Run with: `bun run test-rate-limit.ts`
  </verify>
  <done>
Rate limiting tracks requests per IP per minute.
Stale entries cleaned up periodically.
Configuration via environment variable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create UDP receiver</name>
  <files>
    listener/src/handlers/udp-receiver.ts
  </files>
  <action>
Create listener/src/handlers/udp-receiver.ts:

```typescript
import { insertProfilingData } from "../database/queries";
import { PhpPayloadSchema, PostgresPayloadSchema } from "../middleware/validation";

let udpSocket: ReturnType<typeof Bun.udpSocket> | null = null;

// Stats tracking
let receivedCount = 0;
let errorCount = 0;
let lastError: string | null = null;

/**
 * Start UDP server for receiving profiling data
 * UDP is fire-and-forget - no authentication, no response
 * Use for high-throughput scenarios where some data loss is acceptable
 *
 * @param port UDP port to listen on
 */
export async function startUdpServer(port: number): Promise<void> {
  if (udpSocket) {
    console.log("[UDP] Server already running");
    return;
  }

  udpSocket = await Bun.udpSocket({
    port,
    socket: {
      data(socket, buf, remotePort, remoteAddr) {
        receivedCount++;

        try {
          // Parse JSON from buffer
          const text = buf.toString();
          const payload = JSON.parse(text);

          // Determine payload type and validate
          // UDP payloads must include 'source' field to distinguish type
          const source = payload.source || "php_agent";

          if (source === "postgres_agent") {
            const result = PostgresPayloadSchema.safeParse(payload);
            if (!result.success) {
              errorCount++;
              lastError = `Validation failed: ${result.error.message}`;
              return;
            }

            insertProfilingData.run({
              $correlation_id: result.data.correlation_id || `udp-${Date.now()}`,
              $project: result.data.project,
              $source: "postgres_agent",
              $timestamp: Math.floor(result.data.timestamp),
              $duration_ms: null,
              $payload: JSON.stringify(result.data.data),
            });
          } else {
            // Default: PHP agent
            const result = PhpPayloadSchema.safeParse(payload);
            if (!result.success) {
              errorCount++;
              lastError = `Validation failed: ${result.error.message}`;
              return;
            }

            insertProfilingData.run({
              $correlation_id: result.data.correlation_id,
              $project: result.data.project,
              $source: "php_agent",
              $timestamp: Math.floor(result.data.timestamp),
              $duration_ms: result.data.elapsed_ms,
              $payload: JSON.stringify(payload),
            });
          }
        } catch (error) {
          errorCount++;
          lastError = error instanceof Error ? error.message : "Unknown error";
          // UDP is fire-and-forget - log but don't crash
          console.error(`[UDP] Error processing packet from ${remoteAddr}:${remotePort}:`, error);
        }
      },
    },
  });

  console.log(`[UDP] Server started on port ${port}`);
}

/**
 * Stop UDP server
 */
export function stopUdpServer(): void {
  if (udpSocket) {
    udpSocket.close();
    udpSocket = null;
    console.log("[UDP] Server stopped");
  }
}

/**
 * Get UDP server stats
 */
export function getUdpStats(): {
  running: boolean;
  port: number | null;
  received: number;
  errors: number;
  lastError: string | null;
} {
  return {
    running: udpSocket !== null,
    port: udpSocket?.port ?? null,
    received: receivedCount,
    errors: errorCount,
    lastError,
  };
}
```

NOTE: UDP does not support authentication (no headers). It's intended for internal network use where firewall rules provide security.

For PHP agents behind a firewall, UDP is optional and faster than HTTP.
  </action>
  <verify>
Create test script that:
1. Starts UDP server on port 8444
2. Sends valid PHP payload via UDP:
   ```bash
   echo '{"correlation_id":"test-123","project":"test",...}' | nc -u localhost 8444
   ```
3. Verifies data appears in database
4. Sends invalid JSON, verifies error count increases
5. Stops UDP server

Run with: `bun run test-udp.ts`
  </verify>
  <done>
UDP server receives and parses JSON payloads.
Data is validated with same schemas as HTTP.
Errors are logged but don't crash server.
Stats track received count and errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate rate limiting and UDP into server</name>
  <files>
    listener/src/server.ts
  </files>
  <action>
Update listener/src/server.ts to add rate limiting and UDP:

1. Import new modules:
```typescript
import { checkRateLimit, getClientIp, startRateLimitCleanup, stopRateLimitCleanup, getRateLimitStats } from "./middleware/rate-limit";
import { startUdpServer, stopUdpServer, getUdpStats } from "./handlers/udp-receiver";
```

2. Start rate limit cleanup after database init:
```typescript
startRateLimitCleanup();
```

3. Start UDP server if port configured:
```typescript
const udpPort = Number(Bun.env.BITVILLE_UDP_PORT);
if (udpPort) {
  await startUdpServer(udpPort);
}
```

4. Add rate limiting to HTTP handler (before authentication):
```typescript
async fetch(req, server) {
  const url = new URL(req.url);

  // Skip rate limiting for health checks
  if (url.pathname === "/health" || url.pathname === "/ready") {
    // Handle health checks...
  }

  // Apply rate limiting for ingest endpoints
  if (url.pathname.startsWith("/ingest")) {
    const clientIp = getClientIp(req, server);
    const rateLimit = checkRateLimit(clientIp);

    if (!rateLimit.allowed) {
      return new Response("Too Many Requests", {
        status: 429,
        headers: {
          "Retry-After": String(Math.ceil((rateLimit.resetAt - Date.now()) / 1000)),
          "X-RateLimit-Limit": String(getRateLimitStats().maxRequests),
          "X-RateLimit-Remaining": "0",
          "X-RateLimit-Reset": String(Math.floor(rateLimit.resetAt / 1000)),
        },
      });
    }
  }

  // ... rest of handler
}
```

5. Update /ready endpoint to include UDP and rate limit stats:
```typescript
if (req.method === "GET" && url.pathname === "/ready") {
  const cleanup = getCleanupStatus();
  const udp = getUdpStats();
  const rateLimit = getRateLimitStats();

  return new Response(JSON.stringify({
    ready: true,
    uptime: process.uptime(),
    cleanup: { ... },
    udp: {
      enabled: udp.running,
      port: udp.port,
      received: udp.received,
      errors: udp.errors,
    },
    rateLimit: {
      activeIps: rateLimit.activeIps,
      maxRequests: rateLimit.maxRequests,
    },
  }), {
    headers: { "content-type": "application/json" }
  });
}
```

6. Update shutdown handler:
```typescript
const shutdown = () => {
  console.log("[Listener] Shutting down gracefully...");
  stopCleanupJob();
  stopRateLimitCleanup();
  stopUdpServer();
  server.stop(false);
  // ...
};
```

7. Update .env.example to document new variables:
```bash
# === UDP Configuration ===
# UDP port for fire-and-forget ingestion (no auth, use with firewall)
# Leave unset to disable UDP
# BITVILLE_UDP_PORT=8444

# === Rate Limiting ===
# Max requests per minute per IP (default: 100)
# BITVILLE_RATE_LIMIT=100
```
  </action>
  <verify>
Test rate limiting:
1. Start server
2. Send 100 requests rapidly: `for i in {1..100}; do curl -s http://localhost:8443/ingest/php -H "Authorization: Bearer key"; done`
3. Send 101st request, verify 429 response with Retry-After header

Test UDP:
1. Start server with BITVILLE_UDP_PORT=8444
2. Send UDP packet: `echo '{"correlation_id":"test","project":"test","timestamp":1234567890,"elapsed_ms":600,"request":{"method":"GET","uri":"/test"},"server":{"hostname":"test","php_version":"7.4","sapi":"fpm"}}' | nc -u localhost 8444`
3. Check /ready endpoint, verify udp.received > 0
4. Query database for inserted record

Run: `BITVILLE_UDP_PORT=8444 BITVILLE_DB_PATH=/tmp/test.db BITVILLE_API_KEY_TEST=key bun run src/server.ts`
  </verify>
  <done>
Rate limiting returns 429 when limit exceeded.
Rate limit headers included in 429 response.
UDP server starts when port configured.
/ready endpoint shows UDP and rate limit stats.
Graceful shutdown stops all services.
  </done>
</task>

</tasks>

<verification>
1. Rate limiting works: 101st request in 1 minute returns 429
2. Rate limit headers correct: Retry-After, X-RateLimit-* present
3. UDP server starts on configured port
4. UDP payloads are validated and stored
5. /ready shows UDP stats (received count, errors)
6. Graceful shutdown stops UDP server
7. .env.example documents UDP and rate limit config
</verification>

<success_criteria>
- Rate limiting prevents >100 requests/minute per IP
- 429 responses include proper headers
- UDP server receives and stores profiling data
- UDP payloads validated with same schemas as HTTP
- Both protocols work simultaneously
- All services shut down gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/03-central-listener/03-04-SUMMARY.md`
</output>
