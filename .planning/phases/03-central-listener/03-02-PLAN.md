---
phase: 03-central-listener
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - listener/src/middleware/auth.ts
  - listener/src/middleware/validation.ts
  - listener/src/handlers/php-agent.ts
  - listener/src/handlers/postgres-agent.ts
  - listener/src/server.ts
autonomous: true

must_haves:
  truths:
    - "PHP agents can POST profiling data to /ingest/php with Bearer token authentication"
    - "Invalid API keys receive 401 Unauthorized response"
    - "Malformed JSON payloads receive 400 Bad Request with error details"
    - "Valid payloads are stored in SQLite database immediately"
    - "Multiple projects are supported via different API keys"
  artifacts:
    - path: "listener/src/middleware/auth.ts"
      provides: "API key validation from Authorization header"
      exports: ["authenticateRequest", "AuthContext"]
    - path: "listener/src/middleware/validation.ts"
      provides: "Zod schemas for payload validation"
      exports: ["PhpPayloadSchema", "PostgresPayloadSchema"]
    - path: "listener/src/handlers/php-agent.ts"
      provides: "HTTP handler for PHP agent ingestion"
      exports: ["handlePhpAgent"]
    - path: "listener/src/handlers/postgres-agent.ts"
      provides: "HTTP handler for Postgres agent ingestion"
      exports: ["handlePostgresAgent"]
    - path: "listener/src/server.ts"
      provides: "Main Bun.serve entry point with TLS"
      min_lines: 50
  key_links:
    - from: "listener/src/handlers/php-agent.ts"
      to: "listener/src/database/queries.ts"
      via: "insertProfilingData call"
      pattern: "insertProfilingData"
    - from: "listener/src/server.ts"
      to: "listener/src/handlers/php-agent.ts"
      via: "route handler import"
      pattern: "handlePhpAgent"
---

<objective>
Create HTTP server with TLS, API key authentication, and ingestion endpoints for PHP and Postgres agents.

Purpose: Implement LIST-01 (receive from PHP agents), LIST-02 (receive from Postgres agent), LIST-03 (authorization via API keys), LIST-04 (parse data). This is the core data reception layer.

**LIST-03 Authorization Note:** Network firewall configuration is OUT OF SCOPE for this project. The LIST-03 requirement "Accept connections only from authorized servers" is satisfied by API key authentication implemented in this plan. Each project has a unique API key (BITVILLE_API_KEY_PROJECTNAME=key), and requests without valid Bearer tokens receive 401 Unauthorized. This provides application-level authorization without requiring network-level firewall rules.

Output: Running HTTPS server accepting authenticated profiling data from agents.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-central-listener/03-CONTEXT.md
@.planning/phases/03-central-listener/03-RESEARCH.md
@.planning/phases/03-central-listener/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create authentication middleware</name>
  <files>
    listener/src/middleware/auth.ts
  </files>
  <action>
Create listener/src/middleware/auth.ts:

```typescript
export interface AuthContext {
  projectKey: string;
  isValid: boolean;
  error?: string;
}
```

Implement authenticateRequest(req: Request): AuthContext:
1. Extract Authorization header
2. Check for "Bearer " prefix - if missing, return { projectKey: "", isValid: false, error: "Missing Bearer token" }
3. Extract API key after "Bearer "
4. Load API keys from Bun.env at STARTUP (not per-request):
   - Cache keys in a Map<string, string> (apiKey -> projectName)
   - Scan Bun.env for keys starting with "BITVILLE_API_KEY_"
   - Format: BITVILLE_API_KEY_PROJECTNAME=actual-api-key-uuid
5. Look up apiKey in cached map
6. If found, return { projectKey: projectName.toLowerCase(), isValid: true }
7. If not found, return { projectKey: "", isValid: false, error: "Invalid API key" }

Export function to refresh API keys cache (for runtime updates without restart).

IMPORTANT: Load keys into Map at module initialization, NOT on each request (see research pitfall #4).

This authentication mechanism satisfies LIST-03 (authorization requirement). Network firewall is out of scope - API key validation provides application-level authorization.
  </action>
  <verify>
Create test that:
1. Sets BITVILLE_API_KEY_TESTPROJECT=test-key-123 in env
2. Calls authenticateRequest with valid Bearer token
3. Verifies isValid: true, projectKey: "testproject"
4. Calls with invalid key, verifies isValid: false

Run with: `BITVILLE_API_KEY_TESTPROJECT=test-key-123 bun run test-auth.ts`
  </verify>
  <done>
Authentication middleware validates Bearer tokens against env vars.
API keys are cached at startup for performance.
Invalid/missing tokens return appropriate error context.
LIST-03 authorization satisfied via API key validation (network firewall out of scope).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation schemas and request handlers</name>
  <files>
    listener/src/middleware/validation.ts
    listener/src/handlers/php-agent.ts
    listener/src/handlers/postgres-agent.ts
  </files>
  <action>
Create listener/src/middleware/validation.ts with Zod schemas:

```typescript
import { z } from "zod";

// PHP agent payload schema (matches listener.php output)
export const PhpPayloadSchema = z.object({
  correlation_id: z.string().min(1),
  project: z.string().min(1).max(50),
  timestamp: z.number(),
  elapsed_ms: z.number(),
  threshold_ms: z.number().optional(),
  request: z.object({
    method: z.string(),
    uri: z.string(),
    query_string: z.string().optional(),
    headers: z.record(z.string()).optional(),
    post_data: z.record(z.unknown()).optional(),
  }),
  response: z.object({
    status_code: z.number().optional(),
    headers: z.record(z.string()).optional(),
  }).optional(),
  timing: z.object({
    start_time: z.number(),
    end_time: z.number(),
    duration_ms: z.number(),
  }).optional(),
  xhprof: z.record(z.unknown()).optional(),
  sql: z.object({
    queries: z.array(z.object({
      query: z.string(),
      duration_ms: z.number(),
      stack_trace: z.array(z.string()).optional(),
    })),
    total_queries: z.number(),
    total_duration_ms: z.number(),
  }).nullable().optional(),
  server: z.object({
    hostname: z.string(),
    php_version: z.string(),
    sapi: z.string(),
  }),
  custom: z.record(z.unknown()).optional(),
  fatal_error: z.object({
    type: z.number(),
    message: z.string(),
    file: z.string(),
    line: z.number(),
  }).optional(),
});

// Postgres agent schema (Phase 5 will use this)
export const PostgresPayloadSchema = z.object({
  correlation_id: z.string().optional(),
  project: z.string().min(1).max(50),
  timestamp: z.number(),
  source: z.enum(['pg_stat_activity', 'pg_stat_statements', 'pg_log', 'system_metrics']),
  data: z.record(z.unknown()),
});
```

Create listener/src/handlers/php-agent.ts:
1. Import authenticateRequest, PhpPayloadSchema, insertProfilingData
2. Export async function handlePhpAgent(req: Request): Promise<Response>
3. Call authenticateRequest - return 401 if invalid
4. Parse JSON with try/catch - return 400 on parse error
5. Validate with PhpPayloadSchema.safeParse() - return 400 with details on validation error
6. Store in database via insertProfilingData with source='php_agent'
7. Return 200 OK on success
8. Log errors to console.error with [PHP Agent] prefix

Create listener/src/handlers/postgres-agent.ts with same pattern:
- Use PostgresPayloadSchema
- source='postgres_agent'
- duration_ms = null (DB records don't have request duration)
  </action>
  <verify>
Create test that:
1. Mocks a valid PHP payload matching listener.php structure
2. Calls handlePhpAgent with valid auth and payload
3. Verifies 200 response
4. Queries database for inserted record
5. Tests 400 response for invalid JSON
6. Tests 400 response for schema validation failure

Run with: `BITVILLE_API_KEY_TESTPROJECT=test-key-123 bun run test-handlers.ts`
  </verify>
  <done>
PHP agent handler validates, stores, and returns appropriate responses.
Postgres agent handler ready for Phase 5 integration.
Validation errors include specific field details.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create main HTTP server with TLS</name>
  <files>
    listener/src/server.ts
  </files>
  <action>
Create listener/src/server.ts as main entry point:

1. Import handlers and database initialization
2. Initialize database on startup (call initDatabase())
3. Configure Bun.serve with:

```typescript
const server = Bun.serve({
  port: Number(Bun.env.BITVILLE_PORT) || 8443,
  hostname: "0.0.0.0",

  // TLS configuration (optional - skip if certs not provided)
  tls: Bun.env.BITVILLE_TLS_KEY_PATH ? {
    key: Bun.file(Bun.env.BITVILLE_TLS_KEY_PATH),
    cert: Bun.file(Bun.env.BITVILLE_TLS_CERT_PATH!),
  } : undefined,

  // Static routes for health checks (faster than dynamic)
  routes: {
    "/health": new Response("OK", {
      headers: { "content-type": "text/plain" }
    }),
  },

  // Dynamic request handler
  async fetch(req, server) {
    const url = new URL(req.url);

    if (req.method === "POST") {
      if (url.pathname === "/ingest/php") {
        return handlePhpAgent(req);
      }
      if (url.pathname === "/ingest/postgres") {
        return handlePostgresAgent(req);
      }
    }

    // GET /ready - dynamic readiness check
    if (req.method === "GET" && url.pathname === "/ready") {
      // Could check database connection here
      return new Response(JSON.stringify({
        ready: true,
        uptime: process.uptime(),
      }), {
        headers: { "content-type": "application/json" }
      });
    }

    return new Response("Not Found", { status: 404 });
  },

  error(error) {
    console.error("[Server Error]", error);
    return new Response("Internal Server Error", { status: 500 });
  },
});
```

4. Add graceful shutdown handler:
```typescript
process.on("SIGTERM", () => {
  console.log("[Listener] Shutting down gracefully...");
  server.stop(false);  // Allow in-flight requests
  db.close();
  process.exit(0);
});
```

5. Log startup message with protocol (HTTP vs HTTPS) and port

Make TLS optional - if BITVILLE_TLS_KEY_PATH not set, run without TLS (for local development).
  </action>
  <verify>
Start server without TLS:
```bash
BITVILLE_DB_PATH=/tmp/test-listener.db bun run src/server.ts
```

Test endpoints:
1. curl http://localhost:8443/health - should return "OK"
2. curl http://localhost:8443/ready - should return JSON with ready: true
3. curl -X POST http://localhost:8443/ingest/php - should return 401 (no auth)
4. curl -X POST http://localhost:8443/ingest/php -H "Authorization: Bearer invalid" - should return 401

Test with valid auth:
```bash
BITVILLE_API_KEY_TESTPROJECT=test-key-123 BITVILLE_DB_PATH=/tmp/test-listener.db bun run src/server.ts
```
Then POST valid payload with Bearer test-key-123 - should return 200.
  </verify>
  <done>
Server starts and listens on configured port.
Health check endpoint returns OK.
Readiness endpoint returns JSON status.
POST /ingest/php requires authentication.
POST /ingest/postgres requires authentication.
Valid authenticated requests are stored in database.
Server shuts down gracefully on SIGTERM.
  </done>
</task>

</tasks>

<verification>
1. Server starts without errors: `bun run src/server.ts`
2. Health check works: `curl http://localhost:8443/health` returns "OK"
3. Authentication required: POST without Bearer returns 401
4. Valid PHP payload stored: POST with auth returns 200, data in database
5. Invalid JSON returns 400 with error message
6. Schema validation errors return 400 with field details
7. TypeScript compiles: `bun build src/server.ts --outdir dist`
</verification>

<success_criteria>
- HTTP server running on port 8443 (or configured port)
- TLS works when certificates provided, HTTP fallback for development
- API key authentication via Bearer token (satisfies LIST-03 authorization - network firewall out of scope)
- /ingest/php endpoint accepts PHP agent payloads
- /ingest/postgres endpoint accepts Postgres agent payloads
- Invalid requests receive appropriate error responses (401, 400)
- Valid requests stored in SQLite database
- /health and /ready endpoints for monitoring
</success_criteria>

<output>
After completion, create `.planning/phases/03-central-listener/03-02-SUMMARY.md`
</output>
