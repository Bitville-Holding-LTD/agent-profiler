---
phase: 03-central-listener
plan: 03
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - listener/src/database/cleanup.ts
  - listener/src/server.ts
  - listener/bitville-listener.service
  - listener/.env.example
autonomous: true

must_haves:
  truths:
    - "Data older than 7 days is automatically deleted hourly"
    - "Listener runs as systemd service with automatic restart"
    - "Environment variables configure all runtime settings"
    - "Database disk space is reclaimed after cleanup"
  artifacts:
    - path: "listener/src/database/cleanup.ts"
      provides: "Retention policy with hourly cron"
      exports: ["startCleanupJob", "stopCleanupJob", "runCleanupNow"]
    - path: "listener/bitville-listener.service"
      provides: "systemd service file"
      contains: "bitville-listener"
    - path: "listener/.env.example"
      provides: "Environment variable template"
      contains: "BITVILLE_API_KEY"
  key_links:
    - from: "listener/src/server.ts"
      to: "listener/src/database/cleanup.ts"
      via: "cleanup job initialization"
      pattern: "startCleanupJob"
    - from: "listener/src/database/cleanup.ts"
      to: "listener/src/database/queries.ts"
      via: "deleteOldRecords call"
      pattern: "deleteOldRecords|DELETE.*created_at"
---

<objective>
Implement 7-day retention policy with hourly cleanup, systemd service configuration, and environment variable documentation.

Purpose: Implement STOR-02 (7-day retention), complete daemon deployment configuration. This ensures long-term operation without disk exhaustion.
Output: Production-ready listener with automatic cleanup and service management.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-central-listener/03-CONTEXT.md
@.planning/phases/03-central-listener/03-RESEARCH.md
@.planning/phases/03-central-listener/03-01-SUMMARY.md
@.planning/phases/03-central-listener/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cleanup job with croner</name>
  <files>
    listener/src/database/cleanup.ts
  </files>
  <action>
Create listener/src/database/cleanup.ts:

```typescript
import { Cron } from "croner";
import { db } from "./connection";

// Retention period: 7 days in seconds
const RETENTION_SECONDS = 7 * 24 * 60 * 60;

// Prepared statement for cleanup
const deleteOldRecords = db.query(`
  DELETE FROM profiling_data
  WHERE created_at < ?
`);

let cleanupJob: Cron | null = null;

/**
 * Run cleanup immediately (for testing or manual trigger)
 * @returns Number of records deleted
 */
export function runCleanupNow(): number {
  const cutoffTime = Math.floor(Date.now() / 1000) - RETENTION_SECONDS;

  console.log(`[Cleanup] Running cleanup, deleting records older than ${new Date(cutoffTime * 1000).toISOString()}`);

  const result = deleteOldRecords.run(cutoffTime);
  const deleted = result.changes;

  console.log(`[Cleanup] Deleted ${deleted} records`);

  // Run incremental vacuum to reclaim disk space
  // This is non-blocking and reclaims up to 100 pages
  if (deleted > 0) {
    db.run("PRAGMA incremental_vacuum(100);");
    console.log(`[Cleanup] Incremental vacuum completed`);
  }

  return deleted;
}

/**
 * Start hourly cleanup job
 * Runs at minute 0 of every hour (0 * * * *)
 */
export function startCleanupJob(): void {
  if (cleanupJob) {
    console.log("[Cleanup] Job already running");
    return;
  }

  // Run immediately on startup to clean any accumulated data
  try {
    runCleanupNow();
  } catch (error) {
    console.error("[Cleanup] Initial cleanup failed:", error);
  }

  // Schedule hourly cleanup
  cleanupJob = Cron("0 * * * *", () => {
    try {
      runCleanupNow();
    } catch (error) {
      console.error("[Cleanup] Scheduled cleanup failed:", error);
    }
  });

  console.log("[Cleanup] Hourly cleanup job started (runs at minute 0)");
}

/**
 * Stop cleanup job (for graceful shutdown)
 */
export function stopCleanupJob(): void {
  if (cleanupJob) {
    cleanupJob.stop();
    cleanupJob = null;
    console.log("[Cleanup] Job stopped");
  }
}

/**
 * Get cleanup job status
 */
export function getCleanupStatus(): {
  running: boolean;
  nextRun: Date | null;
  retentionDays: number;
} {
  return {
    running: cleanupJob !== null,
    nextRun: cleanupJob?.nextRun() ?? null,
    retentionDays: 7,
  };
}
```

Export all functions for use in server.ts and testing.
  </action>
  <verify>
Create test that:
1. Inserts test records with created_at = now - 8 days
2. Inserts test records with created_at = now - 1 day
3. Runs runCleanupNow()
4. Verifies old records deleted, recent records remain
5. Checks return value matches deleted count

Run with: `bun run test-cleanup.ts`
  </verify>
  <done>
Cleanup function deletes records older than 7 days.
Incremental vacuum runs after deletions.
Hourly cron job configured correctly.
Job can be started and stopped for graceful shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate cleanup into server and add graceful shutdown</name>
  <files>
    listener/src/server.ts
  </files>
  <action>
Update listener/src/server.ts to integrate cleanup:

1. Import cleanup functions:
```typescript
import { startCleanupJob, stopCleanupJob, getCleanupStatus } from "./database/cleanup";
```

2. Start cleanup job after database initialization:
```typescript
// Initialize database
initDatabase();

// Start hourly cleanup job
startCleanupJob();
```

3. Update /ready endpoint to include cleanup status:
```typescript
if (req.method === "GET" && url.pathname === "/ready") {
  const cleanup = getCleanupStatus();
  return new Response(JSON.stringify({
    ready: true,
    uptime: process.uptime(),
    cleanup: {
      running: cleanup.running,
      nextRun: cleanup.nextRun?.toISOString(),
      retentionDays: cleanup.retentionDays,
    },
  }), {
    headers: { "content-type": "application/json" }
  });
}
```

4. Update SIGTERM handler for complete shutdown:
```typescript
const shutdown = () => {
  console.log("[Listener] Shutting down gracefully...");
  stopCleanupJob();
  server.stop(false);  // Allow in-flight requests to complete

  // Give requests 5 seconds to complete
  setTimeout(() => {
    db.close();
    console.log("[Listener] Shutdown complete");
    process.exit(0);
  }, 5000);
};

process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
```

5. Add optional /admin/cleanup endpoint for manual trigger (only if BITVILLE_ADMIN_ENABLED=true):
```typescript
if (Bun.env.BITVILLE_ADMIN_ENABLED === "true") {
  if (req.method === "POST" && url.pathname === "/admin/cleanup") {
    // Require auth for admin endpoints
    const auth = authenticateRequest(req);
    if (!auth.isValid) {
      return new Response("Unauthorized", { status: 401 });
    }

    const deleted = runCleanupNow();
    return new Response(JSON.stringify({ deleted }), {
      headers: { "content-type": "application/json" }
    });
  }
}
```
  </action>
  <verify>
Start server and verify:
1. Console shows cleanup job started message
2. curl /ready includes cleanup status with nextRun time
3. Send SIGTERM - verify cleanup job stops and database closes
4. If BITVILLE_ADMIN_ENABLED=true, POST /admin/cleanup triggers manual cleanup

Run: `BITVILLE_DB_PATH=/tmp/test.db BITVILLE_API_KEY_TEST=key bun run src/server.ts`
Then: `curl http://localhost:8443/ready | jq`
  </verify>
  <done>
Cleanup job starts automatically on server startup.
Ready endpoint shows cleanup status.
Graceful shutdown stops cleanup and closes database.
Manual cleanup endpoint available when admin mode enabled.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create systemd service and environment template</name>
  <files>
    listener/bitville-listener.service
    listener/.env.example
  </files>
  <action>
Create listener/bitville-listener.service (systemd unit file):

```ini
[Unit]
Description=Bitville APM Central Listener
Documentation=https://github.com/your-org/bitville-monitoring
After=network.target

[Service]
Type=simple
User=bitville
Group=bitville
WorkingDirectory=/opt/bitville-listener

# Main process - Bun runs the TypeScript directly
ExecStart=/home/bitville/.bun/bin/bun run /opt/bitville-listener/src/server.ts

# Restart policy
Restart=always
RestartSec=5
StartLimitInterval=60
StartLimitBurst=3

# Environment
Environment=NODE_ENV=production
EnvironmentFile=/etc/bitville/listener.env

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/bitville

# Resource limits (adjust as needed)
LimitNOFILE=65535
MemoryMax=512M

# Logging
StandardOutput=journal
StandardError=journal
SyslogIdentifier=bitville-listener

[Install]
WantedBy=multi-user.target
```

Create listener/.env.example with all configuration options:

```bash
# Bitville Central Listener Configuration
# Copy to /etc/bitville/listener.env and customize

# === Server Settings ===
# Port to listen on (default: 8443)
BITVILLE_PORT=8443

# === TLS Configuration ===
# Set both to enable HTTPS, leave unset for HTTP (development only)
# BITVILLE_TLS_KEY_PATH=/etc/bitville/listener-key.pem
# BITVILLE_TLS_CERT_PATH=/etc/bitville/listener-cert.pem

# === Database ===
# SQLite database file path
BITVILLE_DB_PATH=/var/lib/bitville/listener.db

# === API Keys ===
# One key per project: BITVILLE_API_KEY_{PROJECT_NAME}=key
# Generate keys with: openssl rand -hex 32
# Example:
# BITVILLE_API_KEY_MYPROJECT=a1b2c3d4e5f6...
# BITVILLE_API_KEY_OTHERPROJECT=x9y8z7w6v5u4...

# === Admin Features ===
# Enable admin endpoints (POST /admin/cleanup)
# BITVILLE_ADMIN_ENABLED=true

# === Logging ===
# Log level: debug, info, warn, error
# BITVILLE_LOG_LEVEL=info
```

Add installation instructions as comments in service file:

```
# Installation:
# 1. Create bitville user: sudo useradd -r -s /bin/false bitville
# 2. Create directories:
#    sudo mkdir -p /opt/bitville-listener /var/lib/bitville /etc/bitville
# 3. Copy listener code: sudo cp -r listener/* /opt/bitville-listener/
# 4. Set permissions:
#    sudo chown -R bitville:bitville /opt/bitville-listener /var/lib/bitville
# 5. Create env file: sudo cp .env.example /etc/bitville/listener.env
#    Edit and add API keys
# 6. Install service: sudo cp bitville-listener.service /etc/systemd/system/
# 7. Enable and start:
#    sudo systemctl daemon-reload
#    sudo systemctl enable bitville-listener
#    sudo systemctl start bitville-listener
# 8. Check status: sudo systemctl status bitville-listener
```
  </action>
  <verify>
Verify files are syntactically correct:
1. systemd-analyze verify bitville-listener.service (if on Linux)
2. Check .env.example has all required variables documented
3. Verify ExecStart path matches project structure
4. Review security hardening options

Note: Full systemd testing requires root access - verify syntax only in plan execution.
  </verify>
  <done>
systemd service file configures production deployment.
Environment template documents all configuration options.
Security hardening applied (NoNewPrivileges, ProtectSystem, etc.).
Installation instructions included as comments.
  </done>
</task>

</tasks>

<verification>
1. Cleanup job runs on schedule: Check logs for "[Cleanup]" messages
2. Old records deleted: Insert test data 8 days old, run cleanup, verify deleted
3. Database space reclaimed: Check file size after cleanup with many deletions
4. Graceful shutdown works: Send SIGTERM, verify orderly shutdown in logs
5. Environment template is complete: All env vars used in code are documented
6. systemd service is valid: `systemd-analyze verify bitville-listener.service`
</verification>

<success_criteria>
- Hourly cleanup job deletes records older than 7 days
- Incremental vacuum reclaims disk space after deletions
- /ready endpoint shows cleanup job status
- Graceful shutdown stops cleanup job and closes database
- systemd service file is production-ready with security hardening
- .env.example documents all configuration options
- Installation instructions are clear and complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-central-listener/03-03-SUMMARY.md`
</output>
