---
phase: 03-central-listener
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - listener/package.json
  - listener/tsconfig.json
  - listener/src/database/schema.sql
  - listener/src/database/connection.ts
  - listener/src/database/queries.ts
  - listener/src/types/payloads.ts
autonomous: true

must_haves:
  truths:
    - "SQLite database initializes with WAL mode on server startup"
    - "Database schema supports PHP and Postgres agent data in unified table"
    - "Prepared statements are created for insert and query operations"
    - "Indexes exist for correlation_id, project+timestamp, duration, source+timestamp"
  artifacts:
    - path: "listener/package.json"
      provides: "Bun project configuration with dependencies"
      contains: "bun:sqlite"
    - path: "listener/src/database/schema.sql"
      provides: "SQLite table and index definitions"
      contains: "profiling_data"
    - path: "listener/src/database/connection.ts"
      provides: "Database connection with WAL mode pragmas"
      exports: ["db", "initDatabase"]
    - path: "listener/src/database/queries.ts"
      provides: "Prepared statements for data operations"
      exports: ["insertProfilingData", "queryByCorrelationId"]
    - path: "listener/src/types/payloads.ts"
      provides: "TypeScript types for incoming payloads"
      exports: ["PhpAgentPayload", "PostgresAgentPayload"]
  key_links:
    - from: "listener/src/database/connection.ts"
      to: "listener/src/database/schema.sql"
      via: "schema execution on init"
      pattern: "db\\.exec|readFileSync.*schema"
---

<objective>
Create database foundation for central listener with SQLite WAL mode, schema, prepared statements, and TypeScript types.

Purpose: Establish data storage layer that all ingestion endpoints will write to. This is the foundation for LIST-04, STOR-01, STOR-03, STOR-04.
Output: Initialized Bun project with SQLite database module ready for request handlers.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-central-listener/03-CONTEXT.md
@.planning/phases/03-central-listener/03-RESEARCH.md
@php-agent/profiling/listener.php (payload structure reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Bun project with dependencies</name>
  <files>
    listener/package.json
    listener/tsconfig.json
  </files>
  <action>
Create listener/ directory at project root.

Initialize Bun project:
```bash
cd listener && bun init -y
```

Add dependencies to package.json:
- croner (8.x) - cron scheduling for cleanup
- zod (3.x) - payload validation

Configure tsconfig.json for strict TypeScript with Bun types.

Set package.json scripts:
- "start": "bun run src/server.ts"
- "dev": "bun --hot run src/server.ts"
  </action>
  <verify>
Run `bun install` in listener/ directory - should complete without errors.
Run `bun --version` to confirm Bun is available.
  </verify>
  <done>
listener/package.json exists with croner and zod dependencies.
listener/tsconfig.json exists with strict mode enabled.
bun install completes successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite schema and database connection</name>
  <files>
    listener/src/database/schema.sql
    listener/src/database/connection.ts
  </files>
  <action>
Create listener/src/database/schema.sql with unified profiling_data table:

```sql
-- Unified table for all profiling data (PHP agents + Postgres agent)
CREATE TABLE IF NOT EXISTS profiling_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    correlation_id TEXT NOT NULL,
    project TEXT NOT NULL,
    source TEXT NOT NULL,  -- 'php_agent' or 'postgres_agent'
    timestamp INTEGER NOT NULL,  -- Unix timestamp (seconds)
    duration_ms REAL,  -- Request duration, NULL for DB-only records
    payload TEXT NOT NULL,  -- Full JSON payload
    created_at INTEGER DEFAULT (strftime('%s', 'now'))
);

-- Indexes for required query patterns (STOR-03)
CREATE INDEX IF NOT EXISTS idx_correlation_id ON profiling_data(correlation_id);
CREATE INDEX IF NOT EXISTS idx_project_timestamp ON profiling_data(project, timestamp);
CREATE INDEX IF NOT EXISTS idx_duration ON profiling_data(duration_ms) WHERE duration_ms IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_source_timestamp ON profiling_data(source, timestamp);
CREATE INDEX IF NOT EXISTS idx_created_at ON profiling_data(created_at);  -- For retention cleanup
```

Create listener/src/database/connection.ts:
- Import Database from "bun:sqlite"
- Read DB path from BITVILLE_DB_PATH env var (default: /var/lib/bitville/listener.db)
- Enable WAL mode FIRST: PRAGMA journal_mode = WAL
- Set performance pragmas: synchronous = NORMAL, cache_size = -50000, temp_store = MEMORY
- Set auto_vacuum = INCREMENTAL for gradual space reclamation
- Read and execute schema.sql using db.exec()
- Export db instance and initDatabase() function

Use relative path for schema.sql: import.meta.dir + "/schema.sql"
  </action>
  <verify>
Create a test script that:
1. Imports initDatabase from connection.ts
2. Calls initDatabase()
3. Queries PRAGMA journal_mode - should return "wal"
4. Queries sqlite_master for profiling_data table - should exist
5. Queries sqlite_master for all indexes - should have 5 indexes

Run with: `bun run test-db.ts`
  </verify>
  <done>
Database initializes with WAL mode.
Schema creates profiling_data table with all required columns.
All 5 indexes are created (correlation_id, project_timestamp, duration, source_timestamp, created_at).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create prepared statements and TypeScript types</name>
  <files>
    listener/src/database/queries.ts
    listener/src/types/payloads.ts
  </files>
  <action>
Create listener/src/types/payloads.ts with TypeScript interfaces:

```typescript
// Matches payload from php-agent/profiling/listener.php
export interface PhpAgentPayload {
  correlation_id: string;
  project: string;
  timestamp: number;  // Unix timestamp (float with microseconds)
  elapsed_ms: number;
  threshold_ms: number;
  request: {
    method: string;
    uri: string;
    query_string?: string;
    headers?: Record<string, string>;
    post_data?: Record<string, unknown>;
  };
  response: {
    status_code?: number;
    headers?: Record<string, string>;
  };
  timing: {
    start_time: number;
    end_time: number;
    duration_ms: number;
  };
  xhprof?: Record<string, unknown>;
  sql?: {
    queries: Array<{
      query: string;
      duration_ms: number;
      stack_trace?: string[];
    }>;
    total_queries: number;
    total_duration_ms: number;
  };
  server: {
    hostname: string;
    php_version: string;
    sapi: string;
  };
  custom?: Record<string, unknown>;
  fatal_error?: {
    type: number;
    message: string;
    file: string;
    line: number;
  };
}

// Postgres agent payload (Phase 5 will define complete structure)
export interface PostgresAgentPayload {
  correlation_id?: string;  // May not have correlation
  project: string;
  timestamp: number;
  source: 'pg_stat_activity' | 'pg_stat_statements' | 'pg_log' | 'system_metrics';
  data: Record<string, unknown>;
}

// Database row type
export interface ProfilingDataRow {
  id: number;
  correlation_id: string;
  project: string;
  source: string;
  timestamp: number;
  duration_ms: number | null;
  payload: string;
  created_at: number;
}
```

Create listener/src/database/queries.ts:
- Import db from connection.ts
- Create prepared statements using db.query():
  - insertProfilingData: INSERT with all columns
  - queryByCorrelationId: SELECT WHERE correlation_id = ?
  - queryByProject: SELECT WHERE project = ? ORDER BY timestamp DESC LIMIT ?
  - queryByProjectTimeRange: SELECT WHERE project = ? AND timestamp BETWEEN ? AND ?
  - deleteOldRecords: DELETE WHERE created_at < ?
  - countByProject: SELECT project, COUNT(*) FROM profiling_data GROUP BY project

Export all prepared statements and wrapper functions.
  </action>
  <verify>
Create test script that:
1. Initializes database
2. Inserts a test PHP payload
3. Queries by correlation_id
4. Verifies returned row matches inserted data
5. Cleans up test data

Run with: `bun run test-queries.ts`
  </verify>
  <done>
TypeScript types match PHP agent payload structure.
Prepared statements compile without errors.
Insert and query operations work correctly.
  </done>
</task>

</tasks>

<verification>
1. `bun install` completes without errors in listener/ directory
2. Database initializes with WAL mode confirmed via PRAGMA query
3. Schema creates table and all 5 indexes
4. Prepared statements execute successfully with test data
5. TypeScript compiles without errors: `bun build src/database/connection.ts --outdir dist`
</verification>

<success_criteria>
- Bun project initialized with croner and zod dependencies
- SQLite database initializes with WAL mode and performance pragmas
- profiling_data table created with unified schema for PHP and Postgres data
- 5 indexes created: correlation_id, project+timestamp, duration (partial), source+timestamp, created_at
- Prepared statements ready for insert and query operations
- TypeScript types defined for incoming payloads
</success_criteria>

<output>
After completion, create `.planning/phases/03-central-listener/03-01-SUMMARY.md`
</output>
