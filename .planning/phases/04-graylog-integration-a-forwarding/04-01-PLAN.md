---
phase: 04-graylog-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - listener/src/database/schema.sql
  - listener/src/database/connection.ts
  - listener/src/database/queries.ts
  - listener/src/types/payloads.ts
  - listener/package.json
  - listener/src/graylog/client.ts
autonomous: true

must_haves:
  truths:
    - "Database has forwarded_to_graylog column (INTEGER 0/1)"
    - "Existing records default to forwarded=1 (assume pre-Phase 4 data sent)"
    - "New records default to forwarded=0 (pending forwarding)"
    - "gelf-pro and opossum packages installed"
    - "GELF client can connect to Graylog and send test message"
  artifacts:
    - path: "listener/src/database/schema.sql"
      provides: "Updated schema with forwarded_to_graylog column"
      contains: "forwarded_to_graylog"
    - path: "listener/src/database/queries.ts"
      provides: "Query functions for replay (getUnforwarded, markAsForwarded)"
      exports: ["getUnforwardedRecords", "markAsForwarded"]
    - path: "listener/src/graylog/client.ts"
      provides: "GELF client wrapper using gelf-pro"
      exports: ["initGelfClient", "sendGelfMessage"]
    - path: "listener/package.json"
      provides: "Dependencies for GELF and circuit breaker"
      contains: "gelf-pro"
  key_links:
    - from: "listener/src/graylog/client.ts"
      to: "Graylog server"
      via: "TCP connection (gelf-pro adapter)"
      pattern: "adapterName.*tcp"
---

<objective>
Create database foundation for Graylog forwarding and set up GELF client.

Purpose: Establish the tracking mechanism (forwarded_to_graylog column) and GELF transport layer that the forwarder will use. This is the foundation for GELF-01, GELF-04.
Output: Database migration applied, gelf-pro client configured and tested.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-graylog-integration-a-forwarding/04-CONTEXT.md
@.planning/phases/04-graylog-integration-a-forwarding/04-RESEARCH.md
@listener/src/database/schema.sql
@listener/src/database/connection.ts
@listener/src/database/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add forwarded_to_graylog column to database</name>
  <files>
    listener/src/database/schema.sql
    listener/src/database/connection.ts
    listener/src/database/queries.ts
    listener/src/types/payloads.ts
  </files>
  <action>
**Update listener/src/database/schema.sql:**

Add column definition to the CREATE TABLE statement:
```sql
forwarded_to_graylog INTEGER NOT NULL DEFAULT 0 CHECK(forwarded_to_graylog IN (0, 1))
```

Add index for efficient replay queries:
```sql
CREATE INDEX IF NOT EXISTS idx_forwarded_to_graylog ON profiling_data(forwarded_to_graylog, id);
```

**Update listener/src/database/connection.ts:**

Add migration logic AFTER schema execution to handle existing tables:
```typescript
// Migration: Add forwarded_to_graylog column if missing
const hasColumn = db.query("PRAGMA table_info(profiling_data)").all()
  .some((col: any) => col.name === 'forwarded_to_graylog');

if (!hasColumn) {
  console.log("[Database] Migrating: Adding forwarded_to_graylog column...");
  // Add column with DEFAULT 1 for existing records (assume already sent)
  db.exec(`
    ALTER TABLE profiling_data
    ADD COLUMN forwarded_to_graylog INTEGER NOT NULL DEFAULT 1
    CHECK(forwarded_to_graylog IN (0, 1))
  `);
  // Create index for replay queries
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_forwarded_to_graylog
    ON profiling_data(forwarded_to_graylog, id)
  `);
  console.log("[Database] Migration complete: forwarded_to_graylog column added");
}
```

**IMPORTANT:** The ALTER TABLE uses DEFAULT 1 for EXISTING records (treat as already forwarded since Phase 4 is new). But schema.sql uses DEFAULT 0 for NEW records created after the code update. This prevents massive replay of historical data.

After migration, change the default for new inserts by updating insertProfilingData to explicitly set forwarded_to_graylog = 0.

**Update listener/src/database/queries.ts:**

1. Update insertProfilingData to explicitly set forwarded_to_graylog = 0:
```typescript
const stmt = db.prepare(`
  INSERT INTO profiling_data
  (correlation_id, project, source, timestamp, duration_ms, payload, forwarded_to_graylog)
  VALUES (?, ?, ?, ?, ?, ?, 0)
`);
```

2. Add new query functions:
```typescript
export function getUnforwardedRecords(limit: number = 100): ProfilingDataRow[] {
  const db = getDatabase();
  if (!db) throw new Error("Database not initialized");

  const stmt = db.prepare(`
    SELECT id, correlation_id, project, source, timestamp, duration_ms, payload, created_at
    FROM profiling_data
    WHERE forwarded_to_graylog = 0
    ORDER BY id ASC
    LIMIT ?
  `);

  return stmt.all(limit) as ProfilingDataRow[];
}

export function markAsForwarded(rowId: number): void {
  const db = getDatabase();
  if (!db) throw new Error("Database not initialized");

  const stmt = db.prepare(`
    UPDATE profiling_data SET forwarded_to_graylog = 1 WHERE id = ?
  `);
  stmt.run(rowId);
}

export function getUnforwardedCount(): number {
  const db = getDatabase();
  if (!db) throw new Error("Database not initialized");

  const stmt = db.prepare(`SELECT COUNT(*) as count FROM profiling_data WHERE forwarded_to_graylog = 0`);
  const result = stmt.get() as { count: number };
  return result.count;
}
```

**Update listener/src/types/payloads.ts:**

Add forwarded_to_graylog to ProfilingDataRow interface:
```typescript
export interface ProfilingDataRow {
  id: number;
  correlation_id: string;
  project: string;
  source: string;
  timestamp: number;
  duration_ms: number | null;
  payload: string;
  created_at: number;
  forwarded_to_graylog?: number;  // 0=pending, 1=forwarded
}
```
  </action>
  <verify>
Create test script listener/test-migration.ts:
```typescript
import { initDatabase, getDatabase } from "./src/database/connection.ts";

const db = initDatabase();

// Check column exists
const columns = db.query("PRAGMA table_info(profiling_data)").all();
const hasColumn = columns.some((c: any) => c.name === 'forwarded_to_graylog');
console.log("Has forwarded_to_graylog column:", hasColumn);

// Check index exists
const indexes = db.query("SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='profiling_data'").all();
console.log("Indexes:", indexes.map((i: any) => i.name));

// Test insert with explicit 0
import { insertProfilingData, getUnforwardedRecords, markAsForwarded } from "./src/database/queries.ts";
const rowId = insertProfilingData({
  correlation_id: "test-migration-" + Date.now(),
  project: "test",
  source: "php_agent",
  timestamp: Date.now() / 1000,
  duration_ms: 100,
  payload: JSON.stringify({ test: true })
});
console.log("Inserted row:", rowId);

// Verify new record has forwarded_to_graylog = 0
const unforwarded = getUnforwardedRecords(10);
console.log("Unforwarded records:", unforwarded.length);

// Mark as forwarded
markAsForwarded(rowId);
const afterMark = getUnforwardedRecords(10);
console.log("After marking, unforwarded:", afterMark.length);

console.log("Migration test passed!");
```

Run: `cd listener && bun run test-migration.ts`
  </verify>
  <done>
forwarded_to_graylog column exists in profiling_data table.
idx_forwarded_to_graylog index exists.
New inserts default to forwarded_to_graylog = 0.
getUnforwardedRecords and markAsForwarded functions work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install GELF dependencies and create client module</name>
  <files>
    listener/package.json
    listener/src/graylog/client.ts
    listener/.env.example
  </files>
  <action>
**Install dependencies:**
```bash
cd listener
bun add gelf-pro opossum
bun add -d @types/opossum
```

**Create listener/src/graylog/client.ts:**

```typescript
/**
 * GELF Client for Graylog Integration
 *
 * Wraps gelf-pro library for sending profiling data to Graylog.
 * Configured via environment variables:
 * - GRAYLOG_HOST: Graylog server hostname (default: 127.0.0.1)
 * - GRAYLOG_PORT: GELF TCP port (default: 12201)
 * - GRAYLOG_FACILITY: Facility name for messages (default: bitville-listener)
 */

import gelf from "gelf-pro";

// Configuration from environment
const GRAYLOG_HOST = Bun.env.GRAYLOG_HOST || "127.0.0.1";
const GRAYLOG_PORT = Number(Bun.env.GRAYLOG_PORT) || 12201;
const GRAYLOG_FACILITY = Bun.env.GRAYLOG_FACILITY || "bitville-listener";
const GRAYLOG_ENABLED = Bun.env.GRAYLOG_ENABLED === "true";

let isInitialized = false;

/**
 * Initialize GELF client with TCP adapter
 *
 * @returns true if Graylog integration is enabled
 */
export function initGelfClient(): boolean {
  if (!GRAYLOG_ENABLED) {
    console.log("[Graylog] Integration disabled (set GRAYLOG_ENABLED=true to enable)");
    return false;
  }

  gelf.setConfig({
    fields: {
      facility: GRAYLOG_FACILITY,
      environment: Bun.env.ENVIRONMENT || "production",
    },
    adapterName: "tcp",
    adapterOptions: {
      host: GRAYLOG_HOST,
      port: GRAYLOG_PORT,
      family: 4,        // IPv4
      timeout: 5000,    // 5 second timeout per message
    },
  });

  isInitialized = true;
  console.log(`[Graylog] Client initialized: ${GRAYLOG_HOST}:${GRAYLOG_PORT}`);
  return true;
}

/**
 * Send message to Graylog via GELF TCP
 *
 * @param message GELF message object
 * @returns Promise that resolves on success, rejects on error
 */
export function sendGelfMessage(message: GelfMessage): Promise<void> {
  if (!GRAYLOG_ENABLED) {
    return Promise.resolve();  // Silently skip if disabled
  }

  if (!isInitialized) {
    return Promise.reject(new Error("GELF client not initialized. Call initGelfClient() first."));
  }

  return new Promise((resolve, reject) => {
    // gelf-pro uses callback API, wrap in Promise
    gelf.info(message.short_message, message, (err: Error | null) => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

/**
 * Check if Graylog integration is enabled and initialized
 */
export function isGraylogEnabled(): boolean {
  return GRAYLOG_ENABLED && isInitialized;
}

/**
 * Get Graylog client status for health checks
 */
export function getGraylogStatus(): { enabled: boolean; host: string; port: number; initialized: boolean } {
  return {
    enabled: GRAYLOG_ENABLED,
    host: GRAYLOG_HOST,
    port: GRAYLOG_PORT,
    initialized: isInitialized,
  };
}

/**
 * GELF message structure
 */
export interface GelfMessage {
  version?: string;
  host?: string;
  short_message: string;
  full_message?: string;
  timestamp?: number;
  level?: number;
  // Custom fields (underscore prefix)
  [key: `_${string}`]: string | number | undefined;
}
```

**Update listener/.env.example:**

Add Graylog configuration section:
```bash
# Graylog Integration (Phase 4)
# Enable GELF forwarding to Graylog
GRAYLOG_ENABLED=false
# Graylog server hostname
GRAYLOG_HOST=127.0.0.1
# GELF TCP input port
GRAYLOG_PORT=12201
# Facility name for GELF messages
GRAYLOG_FACILITY=bitville-listener

# Circuit Breaker State (Phase 4)
# Path to persist circuit breaker state
BITVILLE_STATE_PATH=/var/lib/bitville/circuit-breaker-state.json
```
  </action>
  <verify>
Create test script listener/test-gelf-client.ts:
```typescript
import { initGelfClient, sendGelfMessage, isGraylogEnabled, getGraylogStatus } from "./src/graylog/client.ts";

console.log("GELF Client Test");
console.log("================");

// Test with GRAYLOG_ENABLED=false (default)
const status1 = getGraylogStatus();
console.log("Before init (disabled):", status1);

// Initialize (should report disabled)
const enabled = initGelfClient();
console.log("Init result:", enabled);

// Check status
const status2 = getGraylogStatus();
console.log("After init:", status2);

// Test sending (should silently skip when disabled)
await sendGelfMessage({
  short_message: "Test message from Bitville listener",
  _project: "test",
  _correlation_id: "test-123",
});
console.log("Send completed (skipped because disabled)");

// Test with GRAYLOG_ENABLED=true would need actual Graylog server
// For manual testing: GRAYLOG_ENABLED=true GRAYLOG_HOST=your-graylog bun run test-gelf-client.ts

console.log("\nGELF client module working correctly!");
```

Run: `cd listener && bun run test-gelf-client.ts`

Expected output shows client disabled by default, operations silently skip.
  </verify>
  <done>
gelf-pro and opossum packages installed in package.json.
listener/src/graylog/client.ts exists with initGelfClient and sendGelfMessage functions.
GELF client disabled by default, enabled via GRAYLOG_ENABLED=true.
.env.example documents all Graylog configuration options.
  </done>
</task>

</tasks>

<verification>
1. `bun install` completes successfully with gelf-pro and opossum
2. Database migration adds forwarded_to_graylog column (verified via PRAGMA)
3. New inserts have forwarded_to_graylog = 0
4. getUnforwardedRecords and markAsForwarded work correctly
5. GELF client initializes without errors when disabled
6. TypeScript compiles without errors: `bun build src/graylog/client.ts --outdir dist`
</verification>

<success_criteria>
- forwarded_to_graylog column exists with CHECK constraint (0 or 1)
- idx_forwarded_to_graylog index exists for efficient replay queries
- gelf-pro and opossum packages installed
- GELF client module exports initGelfClient, sendGelfMessage, isGraylogEnabled
- Environment variables documented in .env.example
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-graylog-integration-a-forwarding/04-01-SUMMARY.md`
</output>
