---
phase: 04-graylog-integration
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - listener/src/handlers/php-agent.ts
  - listener/src/handlers/postgres-agent.ts
  - listener/src/handlers/udp-receiver.ts
  - listener/src/graylog/replay.ts
  - listener/src/server.ts
autonomous: false

user_setup:
  - service: graylog
    why: "GELF TCP input for receiving forwarded profiling data"
    env_vars:
      - name: GRAYLOG_HOST
        source: "Graylog server hostname (e.g., graylog.example.com)"
      - name: GRAYLOG_PORT
        source: "GELF TCP input port (typically 12201)"
    dashboard_config:
      - task: "Create GELF TCP input"
        location: "Graylog Web UI -> System -> Inputs -> Select GELF TCP -> Launch new input"

must_haves:
  truths:
    - "All ingestion endpoints trigger async Graylog forwarding"
    - "Forwarding does not block ingestion response (fire-and-forget)"
    - "Replay processes unforwarded records when circuit closes"
    - "Replay stops cleanly when circuit opens mid-replay"
    - "Health endpoint shows Graylog forwarding status"
  artifacts:
    - path: "listener/src/graylog/replay.ts"
      provides: "FIFO replay of unforwarded records"
      exports: ["replayUnforwardedRecords", "getReplayStatus"]
    - path: "listener/src/handlers/php-agent.ts"
      provides: "PHP ingestion with Graylog forwarding"
      contains: "forwardInsertedData"
    - path: "listener/src/handlers/postgres-agent.ts"
      provides: "Postgres ingestion with Graylog forwarding"
      contains: "forwardInsertedData"
    - path: "listener/src/server.ts"
      provides: "Server initialization with Graylog integration"
      contains: "initGelfClient"
  key_links:
    - from: "listener/src/handlers/php-agent.ts"
      to: "listener/src/graylog/forwarder.ts"
      via: "forwardInsertedData call after insert"
      pattern: "forwardInsertedData\\("
    - from: "listener/src/graylog/replay.ts"
      to: "listener/src/graylog/forwarder.ts"
      via: "forwardToGraylog for each buffered record"
      pattern: "forwardToGraylog\\("
    - from: "listener/src/server.ts"
      to: "listener/src/graylog/circuit-breaker.ts"
      via: "createCircuitBreaker with replay callback"
      pattern: "createCircuitBreaker\\(.*replayUnforwardedRecords"
---

<objective>
Wire Graylog forwarding into all ingestion endpoints and create replay mechanism.

Purpose: Complete the integration by connecting all data paths to Graylog and ensuring buffered data is replayed when Graylog recovers. This delivers GELF-01 (forward all data), GELF-04 (buffer and replay).
Output: Fully integrated Graylog forwarding with all data flowing to Graylog when available, buffered when unavailable, and replayed on recovery.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-graylog-integration-a-forwarding/04-CONTEXT.md
@.planning/phases/04-graylog-integration-a-forwarding/04-RESEARCH.md
@listener/src/handlers/php-agent.ts
@listener/src/handlers/postgres-agent.ts
@listener/src/handlers/udp-receiver.ts
@listener/src/server.ts
@listener/src/graylog/forwarder.ts
@listener/src/graylog/circuit-breaker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create replay mechanism for buffered records</name>
  <files>
    listener/src/graylog/replay.ts
  </files>
  <action>
**Create listener/src/graylog/replay.ts:**

```typescript
/**
 * Replay Mechanism for Unforwarded Records
 *
 * Processes buffered profiling data when Graylog recovers:
 * - FIFO order (oldest first)
 * - Batch processing to avoid overwhelming Graylog
 * - Clean exit when circuit breaker opens mid-replay
 *
 * Requirements covered:
 * - GELF-04: Buffer in SQLite during Graylog outages and replay when available
 */

import { getUnforwardedRecords, getUnforwardedCount } from "../database/queries.ts";
import { forwardToGraylog } from "./forwarder.ts";
import { isCircuitOpen, isGraylogEnabled } from "./circuit-breaker.ts";

// Replay configuration
const BATCH_SIZE = 100;       // Records per batch
const BATCH_DELAY_MS = 100;   // Pause between batches to avoid overwhelming Graylog

let isReplaying = false;
let lastReplayStats = {
  started: null as Date | null,
  completed: null as Date | null,
  processed: 0,
  errors: 0,
  interrupted: false,
};

/**
 * Replay all unforwarded records to Graylog
 *
 * Called when circuit breaker closes (Graylog recovers).
 * Processes in FIFO order, stops cleanly if circuit opens.
 */
export async function replayUnforwardedRecords(): Promise<void> {
  // Prevent concurrent replays
  if (isReplaying) {
    console.log("[Replay] Replay already in progress, skipping");
    return;
  }

  // Check if Graylog is enabled
  if (!isGraylogEnabled()) {
    console.log("[Replay] Graylog disabled, skipping replay");
    return;
  }

  // Check initial count
  const totalPending = getUnforwardedCount();
  if (totalPending === 0) {
    console.log("[Replay] No unforwarded records to replay");
    return;
  }

  isReplaying = true;
  lastReplayStats = {
    started: new Date(),
    completed: null,
    processed: 0,
    errors: 0,
    interrupted: false,
  };

  console.log(`[Replay] Starting replay of ${totalPending} buffered records...`);

  try {
    let batchCount = 0;

    while (true) {
      // Check if circuit opened (Graylog failed again)
      if (isCircuitOpen()) {
        console.log("[Replay] Circuit breaker opened, stopping replay");
        lastReplayStats.interrupted = true;
        break;
      }

      // Fetch next batch of unforwarded records
      const records = getUnforwardedRecords(BATCH_SIZE);

      if (records.length === 0) {
        // All records processed
        break;
      }

      batchCount++;
      console.log(`[Replay] Processing batch ${batchCount} (${records.length} records)...`);

      // Process each record in the batch
      for (const record of records) {
        // Check circuit before each send
        if (isCircuitOpen()) {
          console.log("[Replay] Circuit breaker opened mid-batch, stopping replay");
          lastReplayStats.interrupted = true;
          break;
        }

        try {
          await forwardToGraylog(record.id, record);
          lastReplayStats.processed++;
        } catch (err) {
          console.error(`[Replay] Failed to forward record ${record.id}:`, err);
          lastReplayStats.errors++;
          // Continue with next record, circuit breaker will open if needed
        }
      }

      // If circuit opened during batch, exit outer loop
      if (lastReplayStats.interrupted) {
        break;
      }

      // Brief pause between batches to avoid overwhelming Graylog
      if (records.length === BATCH_SIZE) {
        await new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS));
      }
    }
  } finally {
    isReplaying = false;
    lastReplayStats.completed = new Date();

    const duration = lastReplayStats.completed.getTime() - lastReplayStats.started!.getTime();
    console.log(
      `[Replay] Complete: ${lastReplayStats.processed} processed, ` +
      `${lastReplayStats.errors} errors, ${duration}ms` +
      (lastReplayStats.interrupted ? " (interrupted)" : "")
    );
  }
}

/**
 * Get replay status for health checks
 */
export function getReplayStatus(): {
  isReplaying: boolean;
  pendingCount: number;
  lastReplay: {
    started: string | null;
    completed: string | null;
    processed: number;
    errors: number;
    interrupted: boolean;
  };
} {
  return {
    isReplaying,
    pendingCount: getUnforwardedCount(),
    lastReplay: {
      started: lastReplayStats.started?.toISOString() || null,
      completed: lastReplayStats.completed?.toISOString() || null,
      processed: lastReplayStats.processed,
      errors: lastReplayStats.errors,
      interrupted: lastReplayStats.interrupted,
    },
  };
}

/**
 * Check if replay is currently in progress
 */
export function isReplayInProgress(): boolean {
  return isReplaying;
}
```
  </action>
  <verify>
Create test script listener/test-replay.ts:
```typescript
import { initDatabase } from "./src/database/connection.ts";
import { insertProfilingData, getUnforwardedCount } from "./src/database/queries.ts";
import { initGelfClient } from "./src/graylog/client.ts";
import { createCircuitBreaker } from "./src/graylog/circuit-breaker.ts";
import { replayUnforwardedRecords, getReplayStatus, isReplayInProgress } from "./src/graylog/replay.ts";

console.log("Replay Test");
console.log("===========");

// Initialize
initDatabase();
initGelfClient();  // Graylog disabled by default
createCircuitBreaker(() => console.log("Recovery callback would trigger replay"));

// Insert test records (will be marked as not forwarded)
console.log("\n1. Insert test records:");
for (let i = 0; i < 5; i++) {
  insertProfilingData({
    correlation_id: `replay-test-${Date.now()}-${i}`,
    project: "test",
    source: "php_agent",
    timestamp: Date.now() / 1000,
    duration_ms: 100 + i,
    payload: JSON.stringify({ test: true, index: i }),
  });
}
console.log("Inserted 5 test records");
console.log("Unforwarded count:", getUnforwardedCount());

// Test replay status
console.log("\n2. Replay status before:");
console.log(JSON.stringify(getReplayStatus(), null, 2));

// Test replay (will mark records as forwarded since Graylog disabled)
console.log("\n3. Run replay:");
await replayUnforwardedRecords();

// Check status after
console.log("\n4. Replay status after:");
console.log(JSON.stringify(getReplayStatus(), null, 2));
console.log("Unforwarded count:", getUnforwardedCount());

console.log("\nReplay test passed!");
```

Run: `cd listener && bun run test-replay.ts`
  </verify>
  <done>
replayUnforwardedRecords processes buffered records in FIFO order.
Replay stops cleanly when circuit breaker opens.
getReplayStatus returns current replay state for health checks.
Batch processing with 100 records per batch and 100ms delay.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire forwarding into all ingestion handlers</name>
  <files>
    listener/src/handlers/php-agent.ts
    listener/src/handlers/postgres-agent.ts
    listener/src/handlers/udp-receiver.ts
  </files>
  <action>
**Update listener/src/handlers/php-agent.ts:**

Add import at top:
```typescript
import { forwardInsertedData } from "../graylog/forwarder.ts";
```

After the `insertProfilingData` call and before the success response (around line 84-96), add fire-and-forget forwarding:
```typescript
const rowId = insertProfilingData({
  correlation_id: payload.correlation_id,
  project: auth.projectKey,
  source: "php_agent",
  timestamp: payload.timestamp,
  duration_ms: payload.timing?.duration_ms ?? payload.elapsed_ms,
  payload: JSON.stringify(payload),
});

// Fire-and-forget async forward to Graylog (don't await)
forwardInsertedData(rowId, {
  correlation_id: payload.correlation_id,
  project: auth.projectKey,
  source: "php_agent",
  timestamp: payload.timestamp,
  duration_ms: payload.timing?.duration_ms ?? payload.elapsed_ms,
  payload: JSON.stringify(payload),
}).catch(err => {
  // Log error but don't fail the request
  console.error(`[PHP Agent] Graylog forward failed for row ${rowId}:`, err);
});

console.log(
  `[PHP Agent] Stored profiling data: project=${auth.projectKey}, ` +
  `correlation_id=${payload.correlation_id}, row_id=${rowId}`
);
```

**Update listener/src/handlers/postgres-agent.ts:**

Add import at top:
```typescript
import { forwardInsertedData } from "../graylog/forwarder.ts";
```

After the `insertProfilingData` call and before the success response (similar location to php-agent.ts), add fire-and-forget forwarding:
```typescript
const rowId = insertProfilingData({
  correlation_id: payload.correlation_id || `pg-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
  project: auth.projectKey,
  source: "postgres_agent",
  timestamp: payload.timestamp,
  duration_ms: null,
  payload: JSON.stringify(payload),
});

// Fire-and-forget async forward to Graylog (don't await)
forwardInsertedData(rowId, {
  correlation_id: payload.correlation_id || `pg-${Date.now()}`,
  project: auth.projectKey,
  source: "postgres_agent",
  timestamp: payload.timestamp,
  duration_ms: null,
  payload: JSON.stringify(payload),
}).catch(err => {
  console.error(`[Postgres Agent] Graylog forward failed for row ${rowId}:`, err);
});

console.log(
  `[Postgres Agent] Stored monitoring data: project=${auth.projectKey}, ` +
  `source=${payload.source}, row_id=${rowId}`
);
```

**Update listener/src/handlers/udp-receiver.ts:**

Add import at top:
```typescript
import { forwardInsertedData } from "../graylog/forwarder.ts";
```

In the message handler, after `insertProfilingData` call, add fire-and-forget forwarding:
```typescript
const rowId = insertProfilingData({
  correlation_id: payload.correlation_id,
  project: payload.project,  // UDP uses payload project (no auth)
  source: isPhp ? "php_agent" : "postgres_agent",
  timestamp: payload.timestamp,
  duration_ms: isPhp ? (payload.timing?.duration_ms ?? payload.elapsed_ms) : null,
  payload: JSON.stringify(payload),
});

// Fire-and-forget async forward to Graylog
forwardInsertedData(rowId, {
  correlation_id: payload.correlation_id || `udp-${Date.now()}`,
  project: payload.project,
  source: isPhp ? "php_agent" : "postgres_agent",
  timestamp: payload.timestamp,
  duration_ms: isPhp ? (payload.timing?.duration_ms ?? payload.elapsed_ms) : null,
  payload: JSON.stringify(payload),
}).catch(err => {
  console.error(`[UDP] Graylog forward failed for row ${rowId}:`, err);
});
```

**Key pattern:** All handlers use `.catch()` without `await` - this is the fire-and-forget pattern. The ingestion response returns immediately while forwarding happens in the background.
  </action>
  <verify>
Run existing handler tests to ensure they still pass:
```bash
cd listener && bun test src/handlers/handlers.test.ts
```

Verify TypeScript compilation:
```bash
cd listener && bun build src/handlers/php-agent.ts --outdir dist --no-bundle
```

Check that forwardInsertedData import is present in all handlers:
```bash
grep -l "forwardInsertedData" listener/src/handlers/*.ts
```

Expected: php-agent.ts, postgres-agent.ts, udp-receiver.ts all listed.
  </verify>
  <done>
All three handlers (php-agent, postgres-agent, udp-receiver) import forwardInsertedData.
All handlers call forwardInsertedData with .catch() pattern (fire-and-forget).
Existing handler tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Initialize Graylog integration in server startup</name>
  <files>
    listener/src/server.ts
  </files>
  <action>
**Update listener/src/server.ts:**

Add imports at top (after existing imports):
```typescript
import { initGelfClient, getGraylogStatus } from "./graylog/client.ts";
import { createCircuitBreaker, getCircuitBreakerStatus } from "./graylog/circuit-breaker.ts";
import { replayUnforwardedRecords, getReplayStatus } from "./graylog/replay.ts";
```

After database initialization (around line 32-33), add Graylog initialization:
```typescript
// Initialize database on startup
console.log("[Listener] Initializing database...");
const db = initDatabase();
console.log("[Listener] Database initialized successfully");

// Initialize Graylog integration
console.log("[Listener] Initializing Graylog integration...");
const graylogEnabled = initGelfClient();
if (graylogEnabled) {
  // Create circuit breaker with replay callback
  createCircuitBreaker(() => {
    // Called when circuit closes (Graylog recovers)
    replayUnforwardedRecords().catch(err => {
      console.error("[Listener] Replay failed:", err);
    });
  });
  console.log("[Listener] Graylog integration initialized");
} else {
  console.log("[Listener] Graylog integration disabled");
}
```

Update the `/ready` endpoint response to include Graylog status (around line 82-111):
```typescript
// Readiness endpoint (dynamic, includes diagnostics)
if (req.method === "GET" && url.pathname === "/ready") {
  const dbHealthy = getDatabase() !== null;
  const apiKeyCount = getApiKeyCount();
  const cleanup = getCleanupStatus();
  const udp = getUdpStats();
  const rateLimit = getRateLimitStats();
  const graylog = getGraylogStatus();
  const circuitBreaker = getCircuitBreakerStatus();
  const replay = getReplayStatus();

  return new Response(JSON.stringify({
    ready: dbHealthy && apiKeyCount > 0,
    uptime: process.uptime(),
    database: dbHealthy ? "connected" : "disconnected",
    api_keys: apiKeyCount,
    cleanup: {
      running: cleanup.running,
      nextRun: cleanup.nextRun?.toISOString(),
      retentionDays: cleanup.retentionDays,
    },
    udp: {
      enabled: udp.running,
      port: udp.port,
      received: udp.received,
      errors: udp.errors,
    },
    rateLimit: {
      activeIps: rateLimit.activeIps,
      maxRequests: rateLimit.maxRequests,
    },
    graylog: {
      enabled: graylog.enabled,
      host: graylog.host,
      port: graylog.port,
      initialized: graylog.initialized,
      circuitBreaker: circuitBreaker.state,
      stats: circuitBreaker.stats,
    },
    replay: {
      pending: replay.pendingCount,
      isReplaying: replay.isReplaying,
      lastReplay: replay.lastReplay,
    },
  }), {
    status: dbHealthy && apiKeyCount > 0 ? 200 : 503,
    headers: { "content-type": "application/json" },
  });
}
```

Update shutdown handler to include Graylog cleanup (if needed):
```typescript
const shutdown = () => {
  console.log("[Listener] Shutting down gracefully...");

  // Stop all background services
  stopCleanupJob();
  stopRateLimitCleanup();
  stopUdpServer();
  // Note: Graylog circuit breaker state is already persisted on state changes

  // Rest of shutdown...
};
```

Update startup log messages to include Graylog status:
```typescript
// After server starts
console.log(`[Listener] ${protocol} server listening on port ${PORT}`);
console.log(`[Listener] Health check: ${protocol.toLowerCase()}://localhost:${PORT}/health`);
console.log(`[Listener] Readiness check: ${protocol.toLowerCase()}://localhost:${PORT}/ready`);
console.log(`[Listener] PHP agent endpoint: ${protocol.toLowerCase()}://localhost:${PORT}/ingest/php`);
console.log(`[Listener] Postgres agent endpoint: ${protocol.toLowerCase()}://localhost:${PORT}/ingest/postgres`);
console.log(`[Listener] Loaded ${getApiKeyCount()} API key(s)`);
if (graylogEnabled) {
  const graylog = getGraylogStatus();
  console.log(`[Listener] Graylog forwarding: ${graylog.host}:${graylog.port}`);
}
```
  </action>
  <verify>
Start the server and check startup logs:
```bash
cd listener && bun run src/server.ts
```

Expected log output includes:
- "Initializing Graylog integration..."
- "Graylog integration disabled" (when GRAYLOG_ENABLED=false)

Check readiness endpoint:
```bash
curl -s http://localhost:8443/ready | jq '.graylog, .replay'
```

Expected response includes graylog and replay status objects.

Test with Graylog enabled (if Graylog available):
```bash
GRAYLOG_ENABLED=true GRAYLOG_HOST=your-graylog bun run src/server.ts
```
  </verify>
  <done>
Server initializes GELF client on startup.
Circuit breaker created with replay callback.
/ready endpoint includes Graylog status, circuit breaker state, and replay stats.
Startup logs show Graylog configuration.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Graylog forwarding integration:
- Database migration with forwarded_to_graylog column
- GELF client using gelf-pro library
- Circuit breaker with state persistence (5 failures, 60s retry)
- Fire-and-forget forwarding from all ingestion endpoints
- FIFO replay of buffered records when Graylog recovers
- Health endpoint with Graylog status
  </what-built>
  <how-to-verify>
**1. Verify database migration:**
```bash
cd listener
bun run test-migration.ts
```
Should show column exists, index exists, insert/query works.

**2. Verify server starts with Graylog disabled:**
```bash
cd listener
bun run src/server.ts
```
Check logs show "Graylog integration disabled".

**3. Verify health endpoint shows Graylog status:**
```bash
curl -s http://localhost:8443/ready | jq '.'
```
Should include `graylog`, `replay` objects.

**4. (Optional) Test with actual Graylog server:**
If you have a Graylog instance available:
```bash
GRAYLOG_ENABLED=true GRAYLOG_HOST=your-graylog-host GRAYLOG_PORT=12201 \
BITVILLE_API_KEY_TEST=testkey bun run src/server.ts
```

Then send test data:
```bash
curl -X POST http://localhost:8443/ingest/php \
  -H "Authorization: Bearer testkey" \
  -H "Content-Type: application/json" \
  -d '{"correlation_id":"test-123","project":"test","timestamp":1706400000,"elapsed_ms":500,"threshold_ms":500,"request":{"method":"GET","uri":"/test"},"response":{},"timing":{"start_time":1706400000,"end_time":1706400000.5,"duration_ms":500},"server":{"hostname":"test","php_version":"7.4","sapi":"cli"}}'
```

Check Graylog web UI for message with:
- short_message: "php_agent - test"
- _correlation_id: "test-123"
- _project: "test"

**5. Verify all requirements met:**
- [ ] GELF-01: All data forwarded to Graylog (fire-and-forget pattern in handlers)
- [ ] GELF-03: Circuit breaker (opossum with 5 failures, 60s retry)
- [ ] GELF-04: SQLite buffering + replay (forwarded_to_graylog column + replay.ts)
- [ ] GELF-05: Project identifier included (_project field in GELF messages)
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 4, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. All handlers import and call forwardInsertedData
2. Server initializes GELF client and circuit breaker on startup
3. /ready endpoint includes graylog and replay status
4. Replay processes unforwarded records when circuit closes
5. TypeScript compiles without errors
6. Existing tests still pass
</verification>

<success_criteria>
- All ingestion endpoints (PHP, Postgres, UDP) trigger Graylog forwarding
- Forwarding is fire-and-forget (doesn't block response)
- Circuit breaker initialized with replay callback
- Health endpoint shows Graylog enabled/disabled, circuit state, replay stats
- Replay processes buffered records in FIFO order
- Replay stops cleanly when circuit opens mid-replay
</success_criteria>

<output>
After completion, create `.planning/phases/04-graylog-integration-a-forwarding/04-03-SUMMARY.md`
</output>
