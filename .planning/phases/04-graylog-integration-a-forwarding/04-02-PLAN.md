---
phase: 04-graylog-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - listener/src/graylog/circuit-breaker.ts
  - listener/src/graylog/state.ts
  - listener/src/graylog/forwarder.ts
autonomous: true

must_haves:
  truths:
    - "Circuit breaker opens after 5 consecutive failures"
    - "Circuit breaker retry timeout is 60 seconds"
    - "Circuit breaker state persists to disk and survives restarts"
    - "GELF messages include all required fields (correlation_id, project, source, duration_ms)"
    - "Forwarder returns immediately when circuit is open (fail-fast)"
  artifacts:
    - path: "listener/src/graylog/circuit-breaker.ts"
      provides: "Opossum circuit breaker wrapping GELF send"
      exports: ["createCircuitBreaker", "getCircuitBreakerStatus"]
    - path: "listener/src/graylog/state.ts"
      provides: "Circuit breaker state persistence to disk"
      exports: ["loadState", "saveState"]
    - path: "listener/src/graylog/forwarder.ts"
      provides: "Main forwarding logic with GELF message building"
      exports: ["forwardToGraylog", "buildGelfMessage"]
  key_links:
    - from: "listener/src/graylog/forwarder.ts"
      to: "listener/src/graylog/circuit-breaker.ts"
      via: "breaker.fire() call"
      pattern: "breaker\\.fire"
    - from: "listener/src/graylog/circuit-breaker.ts"
      to: "listener/src/graylog/client.ts"
      via: "sendGelfMessage function reference"
      pattern: "sendGelfMessage"
---

<objective>
Create circuit breaker with state persistence and the main forwarder module.

Purpose: Implement resilient Graylog forwarding that fails fast when Graylog is unavailable and automatically recovers. This delivers GELF-03 (circuit breaker) and GELF-05 (project identifier).
Output: Forwarder module ready to be integrated into ingestion handlers.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-graylog-integration-a-forwarding/04-CONTEXT.md
@.planning/phases/04-graylog-integration-a-forwarding/04-RESEARCH.md
@listener/src/graylog/client.ts
@listener/src/database/queries.ts
@listener/src/types/payloads.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create circuit breaker with state persistence</name>
  <files>
    listener/src/graylog/state.ts
    listener/src/graylog/circuit-breaker.ts
  </files>
  <action>
**Create listener/src/graylog/state.ts:**

```typescript
/**
 * Circuit Breaker State Persistence
 *
 * Persists circuit breaker state to disk to survive listener restarts.
 * Prevents retry storm when Graylog is down during restart.
 */

import { writeFileSync, readFileSync, existsSync, mkdirSync } from "node:fs";
import { dirname } from "node:path";

const STATE_FILE = Bun.env.BITVILLE_STATE_PATH || "/var/lib/bitville/circuit-breaker-state.json";

export interface CircuitBreakerState {
  state: 'CLOSED' | 'OPEN' | 'HALF_OPEN';
  failures: number;
  lastFailure: number | null;
  lastStateChange: number;
}

/**
 * Load persisted circuit breaker state from disk
 *
 * @returns Persisted state or null if no state file exists
 */
export function loadState(): CircuitBreakerState | null {
  try {
    if (!existsSync(STATE_FILE)) {
      console.log("[Circuit Breaker] No persisted state found, starting fresh");
      return null;
    }

    const content = readFileSync(STATE_FILE, "utf-8");
    const data = JSON.parse(content);

    // Validate structure
    if (data.state && typeof data.failures === 'number') {
      console.log(`[Circuit Breaker] Loaded persisted state: ${data.state}, failures: ${data.failures}`);
      return data as CircuitBreakerState;
    }

    console.warn("[Circuit Breaker] Invalid state file format, starting fresh");
    return null;
  } catch (err) {
    console.error("[Circuit Breaker] Failed to load state:", err);
    return null;
  }
}

/**
 * Save circuit breaker state to disk
 *
 * @param state Current circuit breaker state to persist
 */
export function saveState(state: CircuitBreakerState): void {
  try {
    // Ensure directory exists
    const dir = dirname(STATE_FILE);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    writeFileSync(STATE_FILE, JSON.stringify(state, null, 2), "utf-8");
    console.log(`[Circuit Breaker] State persisted: ${state.state}`);
  } catch (err) {
    console.error("[Circuit Breaker] Failed to save state:", err);
    // Non-fatal: continue operating without persistence
  }
}

/**
 * Get state file path for diagnostics
 */
export function getStateFilePath(): string {
  return STATE_FILE;
}
```

**Create listener/src/graylog/circuit-breaker.ts:**

```typescript
/**
 * Circuit Breaker for Graylog Connection
 *
 * Wraps GELF send operation with circuit breaker pattern:
 * - Opens after 5 consecutive failures (50% threshold with volume 5)
 * - Retries after 60 seconds
 * - Persists state to disk for restart resilience
 */

import CircuitBreaker from "opossum";
import { sendGelfMessage, type GelfMessage, isGraylogEnabled } from "./client.ts";
import { loadState, saveState, type CircuitBreakerState } from "./state.ts";

// Circuit breaker configuration (matches Phase 2 PHP agent)
const TIMEOUT_MS = 5000;              // 5 second timeout per send
const ERROR_THRESHOLD = 50;           // Open after 50% failures
const RESET_TIMEOUT_MS = 60000;       // 60 second retry timeout
const VOLUME_THRESHOLD = 5;           // Need 5 requests before calculating %

let breaker: CircuitBreaker | null = null;
let onRecoveryCallback: (() => void) | null = null;

/**
 * Create and configure circuit breaker
 *
 * @param onRecovery Callback to trigger replay when circuit closes
 * @returns Circuit breaker instance
 */
export function createCircuitBreaker(onRecovery?: () => void): CircuitBreaker {
  if (breaker) {
    return breaker;
  }

  // Store recovery callback for later invocation
  onRecoveryCallback = onRecovery || null;

  // Load persisted state
  const persistedState = loadState();

  // Create circuit breaker wrapping sendGelfMessage
  breaker = new CircuitBreaker(sendGelfMessage, {
    timeout: TIMEOUT_MS,
    errorThresholdPercentage: ERROR_THRESHOLD,
    resetTimeout: RESET_TIMEOUT_MS,
    volumeThreshold: VOLUME_THRESHOLD,
    name: "graylog-gelf",
  });

  // Restore state from disk if available and circuit should be open
  if (persistedState?.state === 'OPEN') {
    // Check if enough time has passed to transition to half-open
    const timeSinceStateChange = Date.now() - persistedState.lastStateChange;
    if (timeSinceStateChange < RESET_TIMEOUT_MS) {
      // Force circuit open by triggering failures
      console.log("[Circuit Breaker] Restoring OPEN state from disk");
      breaker.open();
    } else {
      console.log("[Circuit Breaker] Persisted OPEN state expired, starting in CLOSED");
    }
  }

  // Event handlers for state persistence
  breaker.on("open", () => {
    console.log("[Circuit Breaker] OPEN - Graylog unavailable, buffering locally");
    persistCurrentState("OPEN");
  });

  breaker.on("close", () => {
    console.log("[Circuit Breaker] CLOSED - Graylog recovered");
    persistCurrentState("CLOSED");

    // Trigger replay of buffered records
    if (onRecoveryCallback) {
      console.log("[Circuit Breaker] Triggering replay of buffered records...");
      // Use setImmediate to not block the close event
      setImmediate(() => {
        onRecoveryCallback!();
      });
    }
  });

  breaker.on("halfOpen", () => {
    console.log("[Circuit Breaker] HALF-OPEN - Testing Graylog connection");
    persistCurrentState("HALF_OPEN");
  });

  breaker.on("fallback", () => {
    // Called when circuit is open and request is rejected
    console.log("[Circuit Breaker] Request rejected (circuit open)");
  });

  breaker.on("failure", (err: Error) => {
    console.error("[Circuit Breaker] GELF send failed:", err.message);
  });

  breaker.on("success", () => {
    // Normal operation, no logging needed
  });

  console.log("[Circuit Breaker] Initialized with 60s retry timeout, 5-request volume threshold");
  return breaker;
}

/**
 * Persist current circuit breaker state to disk
 */
function persistCurrentState(state: 'CLOSED' | 'OPEN' | 'HALF_OPEN'): void {
  if (!breaker) return;

  const stats = breaker.stats;
  const cbState: CircuitBreakerState = {
    state,
    failures: stats.failures,
    lastFailure: stats.latency?.mean || null,
    lastStateChange: Date.now(),
  };

  saveState(cbState);
}

/**
 * Send GELF message through circuit breaker
 *
 * @param message GELF message to send
 * @returns Promise that resolves on success, rejects if circuit open or send fails
 */
export async function sendThroughCircuitBreaker(message: GelfMessage): Promise<void> {
  if (!isGraylogEnabled()) {
    return;  // Silently skip when disabled
  }

  if (!breaker) {
    throw new Error("Circuit breaker not initialized. Call createCircuitBreaker() first.");
  }

  return breaker.fire(message);
}

/**
 * Get circuit breaker status for health checks
 */
export function getCircuitBreakerStatus(): {
  state: string;
  enabled: boolean;
  stats: {
    failures: number;
    successes: number;
    rejects: number;
    timeouts: number;
  };
} {
  if (!breaker) {
    return {
      state: "NOT_INITIALIZED",
      enabled: false,
      stats: { failures: 0, successes: 0, rejects: 0, timeouts: 0 },
    };
  }

  const stats = breaker.stats;
  return {
    state: breaker.opened ? "OPEN" : breaker.halfOpen ? "HALF_OPEN" : "CLOSED",
    enabled: true,
    stats: {
      failures: stats.failures,
      successes: stats.successes,
      rejects: stats.rejects,
      timeouts: stats.timeouts,
    },
  };
}

/**
 * Check if circuit breaker is open (Graylog unavailable)
 */
export function isCircuitOpen(): boolean {
  return breaker?.opened ?? false;
}

/**
 * Get circuit breaker instance for testing
 */
export function getCircuitBreaker(): CircuitBreaker | null {
  return breaker;
}
```
  </action>
  <verify>
Create test script listener/test-circuit-breaker.ts:
```typescript
import { createCircuitBreaker, getCircuitBreakerStatus, isCircuitOpen, sendThroughCircuitBreaker } from "./src/graylog/circuit-breaker.ts";
import { loadState, saveState, getStateFilePath } from "./src/graylog/state.ts";

console.log("Circuit Breaker Test");
console.log("====================");

// Test state persistence
console.log("\n1. State persistence:");
console.log("State file path:", getStateFilePath());
const existingState = loadState();
console.log("Existing state:", existingState);

// Initialize circuit breaker (with Graylog disabled, just testing structure)
console.log("\n2. Circuit breaker initialization:");
let replayTriggered = false;
const breaker = createCircuitBreaker(() => {
  replayTriggered = true;
  console.log("Recovery callback triggered!");
});
console.log("Breaker created:", breaker !== null);

// Check status
console.log("\n3. Circuit breaker status:");
const status = getCircuitBreakerStatus();
console.log("Status:", JSON.stringify(status, null, 2));

// Check open state
console.log("\n4. Is circuit open:", isCircuitOpen());

console.log("\nCircuit breaker test passed!");
```

Run: `cd listener && bun run test-circuit-breaker.ts`
  </verify>
  <done>
Circuit breaker initializes with opossum library.
State persistence loads and saves to disk file.
Recovery callback is registered for replay triggering.
getCircuitBreakerStatus returns current state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create forwarder module with GELF message building</name>
  <files>
    listener/src/graylog/forwarder.ts
  </files>
  <action>
**Create listener/src/graylog/forwarder.ts:**

```typescript
/**
 * Graylog Forwarder Module
 *
 * Main forwarding logic that:
 * 1. Builds GELF messages from profiling data
 * 2. Sends through circuit breaker
 * 3. Marks records as forwarded on success
 *
 * Requirements covered:
 * - GELF-01: Forward all received data to Graylog in GELF format
 * - GELF-05: Include project identifier in all GELF messages
 */

import { sendThroughCircuitBreaker, isCircuitOpen } from "./circuit-breaker.ts";
import { isGraylogEnabled, type GelfMessage } from "./client.ts";
import { markAsForwarded } from "../database/queries.ts";
import type { ProfilingDataRow } from "../types/payloads.ts";

/**
 * Build GELF message from profiling data record
 *
 * Maps profiling_data columns and payload to GELF message structure:
 * - Standard GELF fields: version, host, short_message, timestamp, level
 * - Custom fields: _correlation_id, _project, _source, _duration_ms, etc.
 *
 * @param record Database row from profiling_data table
 * @returns GELF message object ready for sending
 */
export function buildGelfMessage(record: ProfilingDataRow): GelfMessage {
  // Parse payload JSON for additional fields
  let payload: Record<string, any> = {};
  try {
    payload = JSON.parse(record.payload);
  } catch {
    // If payload is not valid JSON, use empty object
  }

  const message: GelfMessage = {
    // Required GELF fields
    version: "1.1",
    host: record.source,  // "php_agent" or "postgres_agent"
    short_message: `${record.source} - ${record.project}`,

    // Optional GELF fields
    timestamp: record.timestamp,
    level: 6,  // INFO level (syslog)
    full_message: record.payload,  // Complete JSON payload

    // Core custom fields (underscore prefix required by GELF spec)
    _correlation_id: record.correlation_id,
    _project: record.project,
    _source: record.source,
    _row_id: record.id,
  };

  // Add duration_ms if present
  if (record.duration_ms !== null) {
    message._duration_ms = record.duration_ms;
  }

  // Extract request context from payload (for PHP agent data)
  if (payload.request?.uri) {
    message._url = String(payload.request.uri).slice(0, 500);  // Truncate long URLs
  }
  if (payload.request?.method) {
    message._method = payload.request.method;
  }
  if (payload.response?.status_code) {
    message._status_code = payload.response.status_code;
  }

  // Extract SQL summary if present
  if (payload.sql?.total_queries !== undefined) {
    message._sql_queries = payload.sql.total_queries;
    message._sql_duration_ms = payload.sql.total_duration_ms;
  }

  // Extract memory info if present
  if (payload.memory?.peak_mb !== undefined) {
    message._memory_peak_mb = payload.memory.peak_mb;
  }

  // Add server info if present
  if (payload.server?.hostname) {
    message._server_hostname = payload.server.hostname;
  }

  return message;
}

/**
 * Forward profiling data record to Graylog
 *
 * Fire-and-forget pattern: Returns quickly, forwarding happens async.
 * If circuit breaker is open, returns immediately without sending.
 *
 * @param rowId Database row ID (for marking as forwarded)
 * @param record Full record data (for building GELF message)
 * @returns Promise that resolves when forwarding completes (or skips)
 */
export async function forwardToGraylog(rowId: number, record: ProfilingDataRow): Promise<void> {
  // Skip if Graylog integration disabled
  if (!isGraylogEnabled()) {
    // Mark as forwarded anyway to prevent replay attempts
    markAsForwarded(rowId);
    return;
  }

  // Skip if circuit breaker is open (fail-fast)
  if (isCircuitOpen()) {
    console.log(`[Forwarder] Circuit open, skipping forward for row ${rowId}`);
    return;  // Record stays with forwarded_to_graylog = 0 for later replay
  }

  try {
    // Build GELF message
    const gelfMessage = buildGelfMessage(record);

    // Send through circuit breaker
    await sendThroughCircuitBreaker(gelfMessage);

    // Mark as forwarded on success
    markAsForwarded(rowId);

    console.log(`[Forwarder] Forwarded row ${rowId} to Graylog (project: ${record.project})`);
  } catch (err) {
    // Circuit breaker will handle state transitions
    // Log error but don't throw - this is fire-and-forget
    console.error(`[Forwarder] Failed to forward row ${rowId}:`, err);
    // Record stays with forwarded_to_graylog = 0 for later replay
  }
}

/**
 * Forward data with inline record construction
 *
 * Convenience function for handlers that builds ProfilingDataRow from insert params.
 * Avoids re-reading from database after insert.
 *
 * @param rowId Inserted row ID
 * @param data Data that was inserted (same shape as insert params)
 */
export async function forwardInsertedData(
  rowId: number,
  data: {
    correlation_id: string;
    project: string;
    source: string;
    timestamp: number;
    duration_ms: number | null;
    payload: string;
  }
): Promise<void> {
  const record: ProfilingDataRow = {
    id: rowId,
    correlation_id: data.correlation_id,
    project: data.project,
    source: data.source,
    timestamp: data.timestamp,
    duration_ms: data.duration_ms,
    payload: data.payload,
    created_at: Math.floor(Date.now() / 1000),
  };

  return forwardToGraylog(rowId, record);
}

/**
 * Check if Graylog forwarding would currently succeed
 *
 * Used by handlers to decide if they should attempt forwarding.
 */
export function canForward(): boolean {
  return isGraylogEnabled() && !isCircuitOpen();
}
```
  </action>
  <verify>
Create test script listener/test-forwarder.ts:
```typescript
import { initGelfClient, isGraylogEnabled } from "./src/graylog/client.ts";
import { createCircuitBreaker, getCircuitBreakerStatus } from "./src/graylog/circuit-breaker.ts";
import { buildGelfMessage, forwardToGraylog, canForward } from "./src/graylog/forwarder.ts";
import type { ProfilingDataRow } from "./src/types/payloads.ts";

console.log("Forwarder Test");
console.log("==============");

// Initialize (Graylog disabled by default)
initGelfClient();
createCircuitBreaker();

// Test buildGelfMessage
console.log("\n1. Build GELF message:");
const testRecord: ProfilingDataRow = {
  id: 123,
  correlation_id: "test-corr-456",
  project: "myproject",
  source: "php_agent",
  timestamp: Date.now() / 1000,
  duration_ms: 250.5,
  payload: JSON.stringify({
    request: {
      method: "GET",
      uri: "/api/users",
    },
    response: {
      status_code: 200,
    },
    sql: {
      total_queries: 5,
      total_duration_ms: 45.2,
    },
    server: {
      hostname: "web1.example.com",
    },
  }),
  created_at: Math.floor(Date.now() / 1000),
};

const gelfMessage = buildGelfMessage(testRecord);
console.log("GELF message:", JSON.stringify(gelfMessage, null, 2));

// Verify required fields
console.assert(gelfMessage.short_message === "php_agent - myproject", "short_message correct");
console.assert(gelfMessage._correlation_id === "test-corr-456", "_correlation_id correct");
console.assert(gelfMessage._project === "myproject", "_project correct");
console.assert(gelfMessage._duration_ms === 250.5, "_duration_ms correct");
console.assert(gelfMessage._url === "/api/users", "_url extracted");
console.assert(gelfMessage._method === "GET", "_method extracted");
console.assert(gelfMessage._status_code === 200, "_status_code extracted");
console.assert(gelfMessage._sql_queries === 5, "_sql_queries extracted");

// Test canForward
console.log("\n2. Can forward:", canForward());
console.log("Circuit breaker status:", getCircuitBreakerStatus());

// Test forwardToGraylog (will skip because Graylog disabled)
console.log("\n3. Forward test record (should skip, Graylog disabled):");
await forwardToGraylog(testRecord.id, testRecord);

console.log("\nForwarder test passed!");
```

Run: `cd listener && bun run test-forwarder.ts`
  </verify>
  <done>
buildGelfMessage creates properly structured GELF messages with all required fields.
forwardToGraylog handles fire-and-forget pattern correctly.
canForward() returns correct status based on circuit breaker and Graylog enabled state.
All custom fields have underscore prefix per GELF spec.
  </done>
</task>

</tasks>

<verification>
1. Circuit breaker initializes with correct thresholds (5 volume, 50% error, 60s retry)
2. State persistence loads and saves correctly to disk
3. Circuit breaker events trigger state persistence
4. Recovery callback is invoked when circuit closes
5. buildGelfMessage creates valid GELF messages with all required fields
6. forwardToGraylog skips when circuit is open (fail-fast)
7. TypeScript compiles without errors: `bun build src/graylog/forwarder.ts --outdir dist`
</verification>

<success_criteria>
- Circuit breaker opens after 5 consecutive failures
- Circuit breaker state persists to disk at BITVILLE_STATE_PATH
- GELF messages include: correlation_id, project, source, duration_ms, url, method, status_code
- Forwarder returns immediately when circuit is open
- Recovery callback triggers replay when circuit closes
- All modules export documented functions
</success_criteria>

<output>
After completion, create `.planning/phases/04-graylog-integration-a-forwarding/04-02-SUMMARY.md`
</output>
