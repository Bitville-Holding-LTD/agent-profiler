---
phase: 02-php-agent-daemon-architecture-a-lifecycle
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - php-agent/daemon/daemon.php
  - php-agent/profiling/transmitter.php
  - php-agent/daemon/health_check.php
  - config/supervisord.conf
  - config/bitville-apm-daemon.service
autonomous: true

must_haves:
  truths:
    - "Daemon drains buffer and transmits to central listener periodically"
    - "listener.php sends to daemon socket instead of direct listener socket"
    - "supervisord config exists for daemon process management"
    - "systemd service file exists as alternative to supervisord"
    - "Health check endpoint returns daemon status as JSON"
  artifacts:
    - path: "php-agent/daemon/health_check.php"
      provides: "HTTP health check endpoint"
      exports: ["HealthCheckServer"]
      min_lines: 40
    - path: "config/supervisord.conf"
      provides: "Supervisord configuration for daemon"
      contains: "bitville-apm-daemon"
    - path: "config/bitville-apm-daemon.service"
      provides: "Systemd unit file for daemon"
      contains: "[Service]"
  key_links:
    - from: "php-agent/daemon/daemon.php"
      to: "php-agent/daemon/transmitter.php"
      via: "require_once and periodic transmission"
      pattern: "transmitter->send"
    - from: "php-agent/profiling/transmitter.php"
      to: "/var/run/bitville-apm/daemon.sock"
      via: "socket path configuration"
      pattern: "daemon\\.sock"
---

<objective>
Complete daemon integration by adding periodic buffer transmission, updating listener.php to use daemon socket, creating process management configs (supervisord/systemd), and adding a health check endpoint.

Purpose: This plan ties everything together so the daemon can run in production. The daemon receives data from PHP requests, buffers it, and periodically transmits to the central listener (when Phase 3 is ready).

Output:
- Updated daemon.php - Periodic buffer drain and transmission
- Updated transmitter.php - Changed socket path for daemon
- health_check.php - HTTP health check server
- supervisord.conf - Process manager configuration
- bitville-apm-daemon.service - Systemd unit file
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-RESEARCH.md
@php-agent/daemon/daemon.php
@php-agent/profiling/transmitter.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HealthCheckServer for daemon monitoring</name>
  <files>php-agent/daemon/health_check.php</files>
  <action>
Create HealthCheckServer class that provides an HTTP endpoint for monitoring tools (Nagios, Prometheus, etc.).

Implementation:

1. Require ReactPHP HTTP server:
```php
// Note: daemon already has react/socket, add react/http
// In daemon directory: composer require react/http
```

2. Class properties:
```php
private $server;
private int $port;
private $statsCallback;
```

3. Constructor:
```php
public function __construct(
    int $port = 9191,
    callable $statsCallback = null
)
```
   - Store port
   - Store callback that returns stats array (daemon will provide this)

4. start(): void
```php
$http = new React\Http\HttpServer(function (Psr\Http\Message\ServerRequestInterface $request) {
    $path = $request->getUri()->getPath();

    if ($path === '/health' || $path === '/') {
        $stats = $this->statsCallback ? ($this->statsCallback)() : [];

        $body = json_encode([
            'status' => 'ok',
            'timestamp' => microtime(true),
            'uptime_seconds' => time() - ($_SERVER['REQUEST_TIME'] ?? time()),
            'stats' => $stats,
        ], JSON_PRETTY_PRINT);

        return new React\Http\Message\Response(
            200,
            ['Content-Type' => 'application/json'],
            $body
        );
    }

    return new React\Http\Message\Response(
        404,
        ['Content-Type' => 'text/plain'],
        'Not found'
    );
});

$socket = new React\Socket\SocketServer('127.0.0.1:' . $this->port);
$http->listen($socket);

error_log("BitvilleAPM: Health check listening on http://127.0.0.1:{$this->port}/health");
```

5. stop(): void
   - Close $socket if exists

Before creating the class, install react/http:
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/php-agent
composer require react/http --no-interaction
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/health_check.php

# Check react/http is installed
ls php-agent/vendor/react/http/src/HttpServer.php
```
  </verify>
  <done>HealthCheckServer provides HTTP endpoint on localhost:9191/health returning JSON with daemon stats</done>
</task>

<task type="auto">
  <name>Task 2: Integrate transmission and health check into daemon.php</name>
  <files>php-agent/daemon/daemon.php</files>
  <action>
Update daemon.php to:
1. Periodically drain buffer and transmit to central listener
2. Start health check server
3. Include complete circuit breaker integration

Changes to make:

1. Add requires at top:
```php
require_once __DIR__ . '/transmitter.php';
require_once __DIR__ . '/health_check.php';
```

2. Add configuration constants:
```php
define('DAEMON_HEALTH_PORT', 9191);
define('DAEMON_FLUSH_INTERVAL', 5); // seconds
define('DAEMON_LISTENER_URL', 'http://localhost:8080/api/profiling'); // Phase 3 will provide real URL
```

3. After buffer manager creation, create transmitter and health check:
```php
// Create circuit breaker and transmitter
$circuitBreaker = new CircuitBreaker('central_listener');
$transmitter = new DaemonTransmitter(DAEMON_LISTENER_URL, 5, $circuitBreaker);

// Create stats callback for health check
$getStats = function() use ($workerLifecycle, $bufferManager, $circuitBreaker) {
    return [
        'worker' => $workerLifecycle->getStats(),
        'buffer' => $bufferManager->getStats(),
        'circuit_breaker' => $circuitBreaker->getStats(),
    ];
};

// Start health check server
$healthCheck = new HealthCheckServer(DAEMON_HEALTH_PORT, $getStats);
$healthCheck->start();
```

4. Add periodic buffer drain and transmission timer:
```php
// Drain buffer and transmit every N seconds
Loop::addPeriodicTimer(DAEMON_FLUSH_INTERVAL, function() use ($bufferManager, $transmitter, $circuitBreaker) {
    // Skip if circuit breaker is open
    if (!$circuitBreaker->isAvailable()) {
        return;
    }

    // Flush memory buffer
    $items = $bufferManager->flush();
    if (empty($items)) {
        return;
    }

    // Transmit each item
    $success = 0;
    $failed = 0;
    foreach ($items as $item) {
        if ($transmitter->send($item)) {
            $success++;
        } else {
            $failed++;
            // Re-add failed item to buffer
            $bufferManager->add($item);

            // Stop if circuit opened
            if (!$circuitBreaker->isAvailable()) {
                error_log("BitvilleAPM: Circuit opened during transmission, re-buffering remaining items");
                // Re-add remaining items
                foreach (array_slice($items, $success + $failed) as $remaining) {
                    $bufferManager->add($remaining);
                }
                break;
            }
        }
    }

    if ($success > 0 || $failed > 0) {
        error_log("BitvilleAPM: Transmitted {$success} items, {$failed} failed");
    }
});
```

5. Update stats logging to include circuit breaker:
```php
Loop::addPeriodicTimer(60.0, function() use ($workerLifecycle, $bufferManager, $circuitBreaker) {
    $stats = $workerLifecycle->getStats();
    $bufferStats = $bufferManager->getStats();
    $cbStats = $circuitBreaker->getStats();
    error_log(sprintf(
        "BitvilleAPM: Stats - requests: %d, memory: %.1fMB, gc_runs: %d, buffer: %d/%d, circuit: %s",
        $stats['request_count'],
        $stats['memory_usage_mb'],
        $stats['gc_runs'],
        $bufferStats['memory_buffer_count'],
        $bufferStats['memory_buffer_limit'],
        $cbStats['state']
    ));
});
```

6. Update startup message to include health check port:
```php
error_log(sprintf(
    "BitvilleAPM: Config - socket: %s, memory_limit: %dMB, max_requests: %d, health: http://127.0.0.1:%d/health",
    DAEMON_SOCKET_PATH,
    DAEMON_MEMORY_LIMIT_MB,
    DAEMON_MAX_REQUESTS,
    DAEMON_HEALTH_PORT
));
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/daemon.php

# Check new requires
grep -n "require.*transmitter\|require.*health_check" php-agent/daemon/daemon.php

# Check periodic transmission timer
grep -n "DAEMON_FLUSH_INTERVAL" php-agent/daemon/daemon.php
```
  </verify>
  <done>daemon.php periodically drains buffer and transmits via DaemonTransmitter with circuit breaker, starts health check server</done>
</task>

<task type="auto">
  <name>Task 3: Update listener.php socket path to use daemon socket</name>
  <files>php-agent/profiling/transmitter.php</files>
  <action>
Update the PHP agent transmitter to send to the daemon's Unix socket instead of the original listener socket.

Changes to php-agent/profiling/transmitter.php:

1. Find the default socket path in send_profiling_data():
```php
$socketPath = $config['listener_socket_path'] ?? '/var/run/bitville-apm/listener.sock';
```

2. Change to daemon socket:
```php
$socketPath = $config['daemon_socket_path'] ?? '/var/run/bitville-apm/daemon.sock';
```

3. Update check_listener_socket() function to use new path:
```php
$socketPath = $config['daemon_socket_path'] ?? '/var/run/bitville-apm/daemon.sock';
```

4. Update comments at top of file to reflect the change:
```php
/**
 * Profiling Data Transmitter
 *
 * Sends profiling data to LOCAL daemon via Unix domain socket
 * with strict 50ms timeout and disk buffer fallback.
 *
 * The local daemon then forwards to the central listener.
 *
 * CRITICAL: This code must NEVER block the request or throw errors
 */
```

IMPORTANT: The daemon uses SOCK_STREAM (ReactPHP requirement), but the current transmitter uses SOCK_DGRAM. We need to change to SOCK_STREAM for compatibility.

5. Update send_via_socket() to use SOCK_STREAM instead of SOCK_DGRAM:
```php
// Change from:
$socket = @socket_create(AF_UNIX, SOCK_DGRAM, 0);

// Change to:
$socket = @socket_create(AF_UNIX, SOCK_STREAM, 0);

// After creating socket, need to connect:
if (@socket_connect($socket, $socketPath) === false) {
    error_log("Profiler: socket_connect failed - " . socket_strerror(socket_last_error($socket)));
    @socket_close($socket);
    return write_to_disk_buffer($json);
}

// Change socket_sendto to socket_send:
// From:
$bytesSent = @socket_sendto($socket, $json, strlen($json), 0, $socketPath);

// To (add newline delimiter for stream protocol):
$bytesSent = @socket_send($socket, $json . "\n", strlen($json) + 1, 0);
```

The full updated send_via_socket() function:
```php
function send_via_socket(string $json, string $socketPath): bool
{
    $socket = null;

    try {
        // Create Unix stream socket (daemon uses SOCK_STREAM via ReactPHP)
        $socket = @socket_create(AF_UNIX, SOCK_STREAM, 0);

        if ($socket === false) {
            error_log("Profiler: socket_create failed - " . socket_strerror(socket_last_error()));
            return write_to_disk_buffer($json);
        }

        // Set 50ms send timeout at socket level
        $result = @socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, [
            'sec' => 0,
            'usec' => TRANSMIT_TIMEOUT_USEC
        ]);

        if ($result === false) {
            error_log("Profiler: socket_set_option failed");
            @socket_close($socket);
            return write_to_disk_buffer($json);
        }

        // Connect to daemon socket (SOCK_STREAM requires connection)
        $startTime = microtime(true);
        if (@socket_connect($socket, $socketPath) === false) {
            $error = socket_last_error($socket);
            $elapsed = (microtime(true) - $startTime) * 1000;
            error_log("Profiler: socket_connect failed - " . socket_strerror($error) . " (elapsed: {$elapsed}ms)");
            @socket_close($socket);
            return write_to_disk_buffer($json);
        }

        // Send data with newline delimiter (for daemon's line-based parsing)
        $dataToSend = $json . "\n";
        $bytesSent = @socket_send($socket, $dataToSend, strlen($dataToSend), 0);
        $elapsed = (microtime(true) - $startTime) * 1000;

        @socket_close($socket);

        if ($bytesSent === false) {
            $error = socket_last_error();
            error_log("Profiler: socket_send failed - " . socket_strerror($error) . " (elapsed: {$elapsed}ms)");
            return write_to_disk_buffer($json);
        }

        // Log if close to timeout
        if ($elapsed > 40) {
            error_log("Profiler: Warning - socket_send took {$elapsed}ms");
        }

        return true;
    } catch (\Throwable $e) {
        error_log("Profiler socket error: " . $e->getMessage());
        if ($socket !== null) {
            @socket_close($socket);
        }
        return write_to_disk_buffer($json);
    }
}
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/profiling/transmitter.php

# Verify socket path changed
grep -n "daemon.sock" php-agent/profiling/transmitter.php

# Verify SOCK_STREAM
grep -n "SOCK_STREAM" php-agent/profiling/transmitter.php

# Verify socket_connect
grep -n "socket_connect" php-agent/profiling/transmitter.php
```
  </verify>
  <done>PHP agent transmitter updated to use SOCK_STREAM and connect to daemon.sock with newline-delimited JSON</done>
</task>

<task type="auto">
  <name>Task 4: Create supervisord and systemd configuration files</name>
  <files>
    config/supervisord.conf
    config/bitville-apm-daemon.service
  </files>
  <action>
Create process management configuration files for both supervisord and systemd.

1. Create config/supervisord.conf:
```ini
; Bitville APM Daemon - Supervisord Configuration
;
; Installation:
;   sudo cp config/supervisord.conf /etc/supervisor/conf.d/bitville-apm-daemon.conf
;   sudo supervisorctl reread
;   sudo supervisorctl update
;
; Management:
;   sudo supervisorctl status bitville-apm-daemon
;   sudo supervisorctl restart bitville-apm-daemon
;   sudo supervisorctl stop bitville-apm-daemon
;   sudo supervisorctl tail -f bitville-apm-daemon

[program:bitville-apm-daemon]
command=/usr/bin/php /var/www/project/profiling/daemon/daemon.php
directory=/var/www/project/profiling/daemon
user=www-data
autostart=true
autorestart=true
startretries=999999
redirect_stderr=true
stdout_logfile=/var/log/bitville-apm/daemon.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=5

; Graceful shutdown - wait up to 30 seconds for buffer flush
stopsignal=TERM
stopwaitsecs=30

; Environment
environment=PATH="/usr/bin:/usr/local/bin"

; Process priority (higher = started later, stopped earlier)
priority=999
```

2. Create config/bitville-apm-daemon.service:
```ini
# Bitville APM Daemon - Systemd Service
#
# Installation:
#   sudo cp config/bitville-apm-daemon.service /etc/systemd/system/
#   sudo systemctl daemon-reload
#   sudo systemctl enable bitville-apm-daemon
#   sudo systemctl start bitville-apm-daemon
#
# Management:
#   sudo systemctl status bitville-apm-daemon
#   sudo systemctl restart bitville-apm-daemon
#   sudo systemctl stop bitville-apm-daemon
#   sudo journalctl -u bitville-apm-daemon -f

[Unit]
Description=Bitville APM Daemon
Documentation=https://github.com/your-org/bitville-monitoring
After=network.target

[Service]
Type=simple
User=www-data
Group=www-data
WorkingDirectory=/var/www/project/profiling/daemon
ExecStart=/usr/bin/php /var/www/project/profiling/daemon/daemon.php

# Restart policy
Restart=always
RestartSec=5

# Graceful shutdown - wait up to 30 seconds
TimeoutStopSec=30

# Remove restart limits (always restart on failure)
StartLimitIntervalSec=0

# Environment
Environment="PATH=/usr/bin:/usr/local/bin"

# Logging to journald
StandardOutput=journal
StandardError=journal
SyslogIdentifier=bitville-apm-daemon

# Runtime directory creation
RuntimeDirectory=bitville-apm
RuntimeDirectoryMode=0755

# State directory for buffers
StateDirectory=bitville-apm
StateDirectoryMode=0755

[Install]
WantedBy=multi-user.target
```

3. Create a README for the config directory if not exists:
```bash
cat > config/README.md << 'EOF'
# Bitville APM Configuration Files

## Daemon Process Management

Choose ONE of the following options:

### Option 1: Supervisord (Recommended)

```bash
# Copy configuration
sudo cp supervisord.conf /etc/supervisor/conf.d/bitville-apm-daemon.conf

# Create log directory
sudo mkdir -p /var/log/bitville-apm
sudo chown www-data:www-data /var/log/bitville-apm

# Reload and start
sudo supervisorctl reread
sudo supervisorctl update

# Check status
sudo supervisorctl status bitville-apm-daemon
```

### Option 2: Systemd

```bash
# Copy service file
sudo cp bitville-apm-daemon.service /etc/systemd/system/

# Reload and enable
sudo systemctl daemon-reload
sudo systemctl enable bitville-apm-daemon

# Start
sudo systemctl start bitville-apm-daemon

# Check status
sudo systemctl status bitville-apm-daemon
```

## Prerequisites

Before starting the daemon:

1. Create runtime directories:
```bash
sudo mkdir -p /var/run/bitville-apm
sudo mkdir -p /var/lib/bitville-apm/buffer
sudo mkdir -p /var/lib/bitville-apm/circuit-breaker-state
sudo chown -R www-data:www-data /var/run/bitville-apm /var/lib/bitville-apm
```

2. Install PHP dependencies:
```bash
cd /var/www/project/profiling
composer install
```
EOF
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring

# Check files exist
ls -la config/supervisord.conf config/bitville-apm-daemon.service

# Validate supervisord config syntax (basic check)
grep -c "program:bitville-apm-daemon" config/supervisord.conf

# Validate systemd service syntax (basic check)
grep -c "\[Service\]" config/bitville-apm-daemon.service
```
  </verify>
  <done>supervisord.conf and bitville-apm-daemon.service created with proper restart policies, graceful shutdown timeouts, and logging configuration</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All PHP syntax valid:
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/daemon.php
php -l php-agent/daemon/health_check.php
php -l php-agent/profiling/transmitter.php
```

2. Config files exist:
```bash
ls -la config/supervisord.conf config/bitville-apm-daemon.service config/README.md
```

3. Integration points verified:
```bash
# Daemon uses all components
grep -c "require" php-agent/daemon/daemon.php

# Transmitter uses daemon socket
grep "daemon.sock" php-agent/profiling/transmitter.php

# Health check provides stats
grep "getStats" php-agent/daemon/health_check.php
```
</verification>

<success_criteria>
- HealthCheckServer provides HTTP /health endpoint on port 9191
- daemon.php integrates transmitter and drains buffer every 5 seconds
- daemon.php starts health check server
- PHP agent transmitter changed from SOCK_DGRAM to SOCK_STREAM
- PHP agent transmitter uses daemon.sock path
- supervisord.conf has correct daemon command, user, restart policy
- systemd service file has correct Type, Restart, TimeoutStopSec
- Config README documents installation steps
- All PHP files pass syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-04-SUMMARY.md`
</output>
