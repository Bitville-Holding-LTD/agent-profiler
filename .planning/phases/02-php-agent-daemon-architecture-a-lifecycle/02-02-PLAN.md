---
phase: 02-php-agent-daemon-architecture-a-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - php-agent/daemon/buffer_manager.php
  - php-agent/daemon/daemon.php
autonomous: true

must_haves:
  truths:
    - "Received profiling data is added to memory buffer"
    - "Memory buffer overflows to disk when full"
    - "Disk buffer files use atomic writes (temp + rename)"
    - "Daemon replays disk buffer on startup"
    - "Buffer is flushed on graceful shutdown"
  artifacts:
    - path: "php-agent/daemon/buffer_manager.php"
      provides: "Memory buffer with disk overflow"
      exports: ["BufferManager"]
      min_lines: 80
  key_links:
    - from: "php-agent/daemon/daemon.php"
      to: "php-agent/daemon/buffer_manager.php"
      via: "require_once and instantiation"
      pattern: "new BufferManager"
    - from: "php-agent/daemon/daemon.php"
      to: "BufferManager::add"
      via: "onDataReceived callback"
      pattern: "bufferManager->add"
---

<objective>
Implement memory buffering for pending profiling data with automatic disk overflow when memory buffer is full.

Purpose: Profiling data must be buffered until it can be sent to the central listener (Phase 3). The buffer prevents data loss when the central listener is temporarily unavailable.

Output:
- buffer_manager.php - Memory buffer with disk overflow
- Updated daemon.php - Integrate buffer manager
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-RESEARCH.md
@php-agent/daemon/daemon.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BufferManager class with memory buffer and disk overflow</name>
  <files>php-agent/daemon/buffer_manager.php</files>
  <action>
Create BufferManager class that holds profiling data in memory and overflows to disk when full.

Implementation:
1. Class properties:
```php
private array $memoryBuffer = [];
private int $memoryBufferLimit;
private string $diskBufferPath;
private int $diskFileCount = 0;
```

2. Constructor:
```php
public function __construct(
    int $memoryBufferLimit = 100,
    string $diskBufferPath = '/var/lib/bitville-apm/buffer'
)
```
   - Store limits
   - Ensure disk buffer directory exists: @mkdir($diskBufferPath, 0755, true)

3. add(array $data): void
   - Add $data to $memoryBuffer
   - If count($memoryBuffer) >= $memoryBufferLimit:
     - Call flushToDisk()
   - Log if adding to full buffer triggered overflow

4. flushToDisk(): void
   - If $memoryBuffer empty, return
   - Generate filename: buffer_{timestamp}_{unique}.json
   - Use atomic write pattern (tempnam + rename) like Phase 1 transmitter:
```php
$tempFile = @tempnam($this->diskBufferPath, 'buffer_');
if ($tempFile === false) {
    error_log("BitvilleAPM: BufferManager tempnam failed");
    return;
}
$json = json_encode($this->memoryBuffer);
if (@file_put_contents($tempFile, $json, LOCK_EX) === false) {
    @unlink($tempFile);
    error_log("BitvilleAPM: BufferManager write failed");
    return;
}
$finalPath = $this->diskBufferPath . '/buffer_' . microtime(true) . '_' . substr(md5(uniqid('', true)), 0, 8) . '.json';
if (!@rename($tempFile, $finalPath)) {
    @unlink($tempFile);
    error_log("BitvilleAPM: BufferManager rename failed");
    return;
}
$this->diskFileCount++;
```
   - Clear $memoryBuffer after successful write
   - Log: error_log("BitvilleAPM: Buffer overflow, wrote {count} items to disk")

5. flush(): array
   - Return current $memoryBuffer contents
   - Clear $memoryBuffer
   - Used by circuit breaker (Plan 02-03) to get data for transmission

6. count(): int
   - Return count($memoryBuffer)

7. replayDiskBuffer(callable $handler): int
   - Scan $diskBufferPath for buffer_*.json files
   - Sort by filename (oldest first for FIFO)
   - For each file:
     - Read and decode JSON
     - If successful, call $handler with each item in the array
     - Delete file after successful processing
   - Return count of items replayed
   - Log: error_log("BitvilleAPM: Replayed {count} items from disk buffer")

8. getStats(): array
```php
return [
    'memory_buffer_count' => count($this->memoryBuffer),
    'memory_buffer_limit' => $this->memoryBufferLimit,
    'disk_overflow_count' => $this->diskFileCount,
    'disk_buffer_path' => $this->diskBufferPath,
];
```

9. getDiskBufferFileCount(): int
   - Return count of buffer_*.json files in disk path
   - Use glob($this->diskBufferPath . '/buffer_*.json')

Error handling:
- All file operations wrapped in try-catch or @ suppressed
- Never throw exceptions, log via error_log
- Graceful degradation if disk unavailable
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/buffer_manager.php

# Test BufferManager
php -r "
require_once 'php-agent/daemon/buffer_manager.php';
\$bufferPath = '/tmp/bitville-test-buffer-' . getmypid();
@mkdir(\$bufferPath, 0755, true);

\$bm = new BufferManager(5, \$bufferPath);

// Add items
for (\$i = 0; \$i < 3; \$i++) {
    \$bm->add(['id' => \$i, 'data' => 'test']);
}
echo 'After 3 items: ' . \$bm->count() . ' in memory' . PHP_EOL;

// Add more to trigger overflow
for (\$i = 3; \$i < 8; \$i++) {
    \$bm->add(['id' => \$i, 'data' => 'test']);
}
echo 'After 8 items: ' . \$bm->count() . ' in memory, ' . \$bm->getDiskBufferFileCount() . ' disk files' . PHP_EOL;

// Test replay
\$replayed = 0;
\$bm->replayDiskBuffer(function(\$item) use (&\$replayed) {
    \$replayed++;
});
echo 'Replayed: ' . \$replayed . ' items' . PHP_EOL;

// Cleanup
@rmdir(\$bufferPath);
"
```
  </verify>
  <done>BufferManager class with memory buffer, disk overflow via atomic writes, replay functionality for disk buffer</done>
</task>

<task type="auto">
  <name>Task 2: Integrate BufferManager into daemon.php</name>
  <files>php-agent/daemon/daemon.php</files>
  <action>
Update daemon.php to use BufferManager for incoming profiling data.

Changes to make:

1. Add require at top (after other requires):
```php
require_once __DIR__ . '/buffer_manager.php';
```

2. Add buffer configuration constants:
```php
define('DAEMON_BUFFER_LIMIT', 100);
define('DAEMON_BUFFER_PATH', '/var/lib/bitville-apm/buffer');
```

3. After runtime directory creation, create buffer directory:
```php
if (!is_dir(DAEMON_BUFFER_PATH)) {
    @mkdir(DAEMON_BUFFER_PATH, 0755, true);
}
```

4. Initialize BufferManager (after WorkerLifecycle creation):
```php
$bufferManager = new BufferManager(DAEMON_BUFFER_LIMIT, DAEMON_BUFFER_PATH);
```

5. Update $onDataReceived callback to use buffer:
```php
$onDataReceived = function(array $profilingData) use ($workerLifecycle, $bufferManager) {
    $workerLifecycle->incrementRequests();
    $bufferManager->add($profilingData);

    $correlationId = $profilingData['correlation_id'] ?? 'unknown';
    error_log("BitvilleAPM: Buffered profiling data for request {$correlationId}");
};
```

6. In the graceful shutdown section, flush buffer before stopping:
```php
if ($shouldShutdown) {
    error_log("BitvilleAPM: Shutting down...");
    // Flush remaining buffer to disk before exit
    $bufferManager->flushToDisk();
    error_log("BitvilleAPM: Buffer flushed to disk");
    $socketServer->stop();
    Loop::stop();
    return;
}
```

7. Also flush buffer when worker restart triggered:
```php
if ($workerLifecycle->shouldRestart()) {
    error_log("BitvilleAPM: Worker restart triggered, flushing buffer...");
    $bufferManager->flushToDisk();
    $socketServer->stop();
    Loop::stop();
    exit(0);
}
```

8. On daemon startup, replay any existing disk buffer files:
```php
// After bufferManager creation but before starting socket server
error_log("BitvilleAPM: Checking for buffered data from previous run...");
$replayedCount = $bufferManager->replayDiskBuffer(function($item) use ($bufferManager) {
    // Re-add to memory buffer for processing by circuit breaker (Plan 02-03)
    $bufferManager->add($item);
});
if ($replayedCount > 0) {
    error_log("BitvilleAPM: Replayed {$replayedCount} items from disk buffer");
}
```

9. Update stats logging to include buffer info:
```php
Loop::addPeriodicTimer(60.0, function() use ($workerLifecycle, $bufferManager) {
    $stats = $workerLifecycle->getStats();
    $bufferStats = $bufferManager->getStats();
    error_log(sprintf(
        "BitvilleAPM: Stats - requests: %d, memory: %.1fMB, gc_runs: %d, buffer: %d/%d, disk_overflows: %d",
        $stats['request_count'],
        $stats['memory_usage_mb'],
        $stats['gc_runs'],
        $bufferStats['memory_buffer_count'],
        $bufferStats['memory_buffer_limit'],
        $bufferStats['disk_overflow_count']
    ));
});
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/daemon.php

# Check that buffer_manager is required
grep -n "require.*buffer_manager" php-agent/daemon/daemon.php

# Check that BufferManager is instantiated
grep -n "new BufferManager" php-agent/daemon/daemon.php

# Check buffer flush on shutdown
grep -n "flushToDisk" php-agent/daemon/daemon.php
```
  </verify>
  <done>daemon.php integrates BufferManager for all incoming profiling data, flushes to disk on shutdown/restart, replays disk buffer on startup</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Syntax validation:
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/buffer_manager.php
php -l php-agent/daemon/daemon.php
```

2. BufferManager complete test:
```bash
php -r "
require_once 'php-agent/daemon/buffer_manager.php';
\$bufferPath = '/tmp/bitville-buffer-test-' . getmypid();
@mkdir(\$bufferPath, 0755, true);

\$bm = new BufferManager(3, \$bufferPath);

// Fill and overflow
for (\$i = 0; \$i < 10; \$i++) {
    \$bm->add(['correlation_id' => 'test-' . \$i]);
}

echo 'Stats: ';
print_r(\$bm->getStats());
echo 'Disk files: ' . \$bm->getDiskBufferFileCount() . PHP_EOL;

// Cleanup test directory
array_map('unlink', glob(\$bufferPath . '/*'));
@rmdir(\$bufferPath);
"
```

3. Integration check:
```bash
grep -c "bufferManager" php-agent/daemon/daemon.php
```
</verification>

<success_criteria>
- BufferManager class holds up to N items in memory (default 100)
- When memory buffer full, atomic overflow to disk with tempnam+rename
- replayDiskBuffer() reads and deletes disk files in FIFO order
- daemon.php adds all incoming data to buffer
- daemon.php flushes buffer to disk on SIGTERM
- daemon.php flushes buffer to disk on worker restart
- daemon.php replays disk buffer on startup
- All PHP files pass syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-02-SUMMARY.md`
</output>
