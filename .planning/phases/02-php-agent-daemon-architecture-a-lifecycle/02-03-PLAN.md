---
phase: 02-php-agent-daemon-architecture-a-lifecycle
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - php-agent/daemon/circuit_breaker.php
  - php-agent/daemon/transmitter.php
autonomous: true

must_haves:
  truths:
    - "Circuit breaker tracks consecutive transmission failures"
    - "Circuit breaker opens after 5 consecutive failures"
    - "Circuit breaker enters half-open state after 60 seconds"
    - "Circuit breaker state persists across daemon restarts"
    - "Transmitter sends data to central listener placeholder endpoint"
    - "Failed transmissions trigger circuit breaker failure count"
  artifacts:
    - path: "php-agent/daemon/circuit_breaker.php"
      provides: "Circuit breaker pattern implementation"
      exports: ["CircuitBreaker"]
      min_lines: 80
    - path: "php-agent/daemon/transmitter.php"
      provides: "HTTP transmission to central listener"
      exports: ["DaemonTransmitter"]
      min_lines: 50
  key_links:
    - from: "php-agent/daemon/transmitter.php"
      to: "php-agent/daemon/circuit_breaker.php"
      via: "require_once and instantiation"
      pattern: "new CircuitBreaker"
---

<objective>
Implement circuit breaker pattern to auto-disable profiling data transmission after consecutive failures, and create the transmitter component that will forward data to the central listener.

Purpose: The circuit breaker prevents the daemon from wasting resources trying to transmit to an unavailable central listener. When the circuit is open, data accumulates in the buffer (Plan 02-02) until the listener recovers.

Output:
- circuit_breaker.php - Circuit breaker implementation with persistent state
- transmitter.php - Daemon transmitter for forwarding to central listener
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreaker class with persistent state</name>
  <files>php-agent/daemon/circuit_breaker.php</files>
  <action>
Create CircuitBreaker class implementing the circuit breaker pattern with file-based state persistence.

Implementation:

1. Circuit states as constants:
```php
const STATE_CLOSED = 'closed';      // Normal operation
const STATE_OPEN = 'open';          // Failing, reject requests
const STATE_HALF_OPEN = 'half_open'; // Testing if recovered
```

2. Class properties:
```php
private string $name;
private int $failureThreshold;
private int $retryTimeout;
private string $stateFilePath;

// In-memory state (loaded from/saved to file)
private string $state = self::STATE_CLOSED;
private int $failureCount = 0;
private float $lastFailureTime = 0;
private float $openedAt = 0;
```

3. Constructor:
```php
public function __construct(
    string $name,
    int $failureThreshold = 5,
    int $retryTimeout = 60,
    string $stateDirectory = '/var/lib/bitville-apm/circuit-breaker-state'
)
```
   - Store parameters
   - Ensure state directory exists: @mkdir($stateDirectory, 0755, true)
   - Set $stateFilePath = $stateDirectory . '/' . $name . '.state'
   - Call loadState() to restore from disk

4. loadState(): void
   - If file doesn't exist, use defaults (closed, 0 failures)
   - Read and json_decode file contents
   - Restore: $state, $failureCount, $lastFailureTime, $openedAt
   - Log if state was restored: error_log("BitvilleAPM: CircuitBreaker {$name} restored state: {$state}")

5. saveState(): void
   - Atomic write (tempnam + rename) like buffer manager:
```php
$data = json_encode([
    'state' => $this->state,
    'failure_count' => $this->failureCount,
    'last_failure_time' => $this->lastFailureTime,
    'opened_at' => $this->openedAt,
]);
$tempFile = @tempnam(dirname($this->stateFilePath), 'cb_');
if ($tempFile && @file_put_contents($tempFile, $data) !== false) {
    @rename($tempFile, $this->stateFilePath);
}
```

6. isAvailable(): bool
   - If STATE_CLOSED: return true
   - If STATE_OPEN:
     - Check if retry timeout elapsed: microtime(true) - $openedAt > $retryTimeout
     - If elapsed, transition to STATE_HALF_OPEN, saveState(), log, return true
     - Otherwise return false
   - If STATE_HALF_OPEN: return true (allow one test request)

7. recordSuccess(): void
   - If STATE_HALF_OPEN:
     - Transition to STATE_CLOSED
     - Reset: $failureCount = 0, $lastFailureTime = 0, $openedAt = 0
     - saveState()
     - Log: error_log("BitvilleAPM: CircuitBreaker {$name} closed after successful test")
   - If STATE_CLOSED:
     - Reset $failureCount = 0 (successful request resets counter)

8. recordFailure(): void
   - $failureCount++
   - $lastFailureTime = microtime(true)
   - If STATE_HALF_OPEN:
     - Immediately transition to STATE_OPEN
     - $openedAt = microtime(true)
     - saveState()
     - Log: error_log("BitvilleAPM: CircuitBreaker {$name} reopened after half-open failure")
   - If STATE_CLOSED and $failureCount >= $failureThreshold:
     - Transition to STATE_OPEN
     - $openedAt = microtime(true)
     - saveState()
     - Log: error_log("BitvilleAPM: CircuitBreaker {$name} opened after {$failureCount} failures")
   - Else:
     - saveState() (persist failure count)

9. getState(): string
   - Return $this->state

10. getStats(): array
```php
return [
    'name' => $this->name,
    'state' => $this->state,
    'failure_count' => $this->failureCount,
    'failure_threshold' => $this->failureThreshold,
    'retry_timeout' => $this->retryTimeout,
    'last_failure_time' => $this->lastFailureTime,
    'opened_at' => $this->openedAt,
];
```

11. reset(): void - For testing/manual intervention
   - Set STATE_CLOSED, reset counters, saveState()
   - Log: error_log("BitvilleAPM: CircuitBreaker {$name} manually reset")

Error handling:
- All file operations @ suppressed or try-caught
- If state file unreadable, use defaults
- Never throw exceptions
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/circuit_breaker.php

# Test circuit breaker state transitions
php -r "
require_once 'php-agent/daemon/circuit_breaker.php';
\$stateDir = '/tmp/cb-test-' . getmypid();
@mkdir(\$stateDir, 0755, true);

\$cb = new CircuitBreaker('test', 3, 2, \$stateDir);

echo 'Initial state: ' . \$cb->getState() . PHP_EOL;
echo 'Available: ' . (\$cb->isAvailable() ? 'yes' : 'no') . PHP_EOL;

// Record 3 failures to open circuit
for (\$i = 0; \$i < 3; \$i++) {
    \$cb->recordFailure();
}
echo 'After 3 failures: ' . \$cb->getState() . PHP_EOL;
echo 'Available: ' . (\$cb->isAvailable() ? 'yes' : 'no') . PHP_EOL;

// Wait for retry timeout (2 seconds)
echo 'Waiting 2.5 seconds for retry timeout...' . PHP_EOL;
sleep(3);
echo 'After timeout, available: ' . (\$cb->isAvailable() ? 'yes' : 'no') . PHP_EOL;
echo 'State after timeout check: ' . \$cb->getState() . PHP_EOL;

// Success closes circuit
\$cb->recordSuccess();
echo 'After success: ' . \$cb->getState() . PHP_EOL;

// Cleanup
@unlink(\$stateDir . '/test.state');
@rmdir(\$stateDir);
"
```
  </verify>
  <done>CircuitBreaker class with open/closed/half-open states, failure counting, retry timeout, persistent state file</done>
</task>

<task type="auto">
  <name>Task 2: Create DaemonTransmitter for forwarding to central listener</name>
  <files>php-agent/daemon/transmitter.php</files>
  <action>
Create DaemonTransmitter class that sends profiling data to the central listener, with circuit breaker integration.

NOTE: Phase 3 will implement the central listener. For now, use a configurable endpoint that defaults to localhost:8080/api/profiling. This lets us test the transmission logic without the full listener.

Implementation:

1. Class properties:
```php
private string $listenerUrl;
private int $timeout;
private CircuitBreaker $circuitBreaker;
```

2. Constructor:
```php
public function __construct(
    string $listenerUrl = 'http://localhost:8080/api/profiling',
    int $timeout = 5,
    ?CircuitBreaker $circuitBreaker = null
)
```
   - Store $listenerUrl and $timeout
   - If $circuitBreaker null, create default:
     $circuitBreaker = new CircuitBreaker('central_listener')
   - Store $circuitBreaker

3. send(array $data): bool
   - Check circuit breaker first:
```php
if (!$this->circuitBreaker->isAvailable()) {
    error_log("BitvilleAPM: Transmitter circuit open, skipping send");
    return false;
}
```
   - Encode data as JSON
   - Use cURL for HTTP POST with timeout:
```php
$json = json_encode($data);
$ch = curl_init($this->listenerUrl);
curl_setopt_array($ch, [
    CURLOPT_POST => true,
    CURLOPT_POSTFIELDS => $json,
    CURLOPT_HTTPHEADER => [
        'Content-Type: application/json',
        'Content-Length: ' . strlen($json),
    ],
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_TIMEOUT => $this->timeout,
    CURLOPT_CONNECTTIMEOUT => 2,
]);

$response = curl_exec($ch);
$httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
$error = curl_error($ch);
curl_close($ch);
```
   - On success (HTTP 2xx):
```php
if ($httpCode >= 200 && $httpCode < 300) {
    $this->circuitBreaker->recordSuccess();
    return true;
}
```
   - On failure (error or non-2xx):
```php
$this->circuitBreaker->recordFailure();
error_log("BitvilleAPM: Transmitter failed - HTTP {$httpCode}, error: {$error}");
return false;
```

4. sendBatch(array $items): array
   - Send multiple items, return ['success' => N, 'failed' => M]
   - For each item, call send()
   - Stop on circuit breaker open (return partial results)

5. isCircuitOpen(): bool
   - Return !$this->circuitBreaker->isAvailable()

6. getStats(): array
```php
return [
    'listener_url' => $this->listenerUrl,
    'timeout' => $this->timeout,
    'circuit_breaker' => $this->circuitBreaker->getStats(),
];
```

7. getCircuitBreaker(): CircuitBreaker
   - Return $this->circuitBreaker (for direct state access)

Require circuit_breaker.php at top of file:
```php
require_once __DIR__ . '/circuit_breaker.php';
```

Error handling:
- cURL errors logged but not thrown
- Circuit breaker handles retry logic
- Return false on any failure
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/transmitter.php

# Test transmitter (will fail on connection, but circuit breaker should work)
php -r "
require_once 'php-agent/daemon/circuit_breaker.php';
require_once 'php-agent/daemon/transmitter.php';

\$stateDir = '/tmp/transmitter-test-' . getmypid();
@mkdir(\$stateDir, 0755, true);

\$cb = new CircuitBreaker('test_listener', 3, 5, \$stateDir);
\$tx = new DaemonTransmitter('http://localhost:9999/nonexistent', 1, \$cb);

echo 'Initial circuit state: ' . \$cb->getState() . PHP_EOL;

// Try to send (will fail - no server)
for (\$i = 0; \$i < 5; \$i++) {
    \$result = \$tx->send(['test' => \$i]);
    echo 'Send ' . \$i . ' result: ' . (\$result ? 'success' : 'failed') . ', circuit: ' . \$cb->getState() . PHP_EOL;
}

// Cleanup
@unlink(\$stateDir . '/test_listener.state');
@rmdir(\$stateDir);
"
```
  </verify>
  <done>DaemonTransmitter sends HTTP POST to central listener, integrates circuit breaker for failure handling, batch send support</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Syntax validation:
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/circuit_breaker.php
php -l php-agent/daemon/transmitter.php
```

2. Circuit breaker state persistence test:
```bash
php -r "
require_once 'php-agent/daemon/circuit_breaker.php';
\$stateDir = '/tmp/cb-persist-test';
@mkdir(\$stateDir, 0755, true);

// Instance 1: Record failures and open circuit
\$cb1 = new CircuitBreaker('persist_test', 3, 60, \$stateDir);
\$cb1->recordFailure();
\$cb1->recordFailure();
\$cb1->recordFailure();
echo 'Instance 1 state: ' . \$cb1->getState() . PHP_EOL;
unset(\$cb1);

// Instance 2: Should load opened state from disk
\$cb2 = new CircuitBreaker('persist_test', 3, 60, \$stateDir);
echo 'Instance 2 state (loaded): ' . \$cb2->getState() . PHP_EOL;

// Cleanup
@unlink(\$stateDir . '/persist_test.state');
@rmdir(\$stateDir);
"
```

3. Integration between transmitter and circuit breaker:
```bash
grep -n "CircuitBreaker" php-agent/daemon/transmitter.php | head -5
```
</verification>

<success_criteria>
- CircuitBreaker tracks consecutive failures (threshold 5)
- CircuitBreaker opens after threshold exceeded
- CircuitBreaker transitions to half-open after 60 second timeout
- CircuitBreaker state persists to file (survives daemon restart)
- DaemonTransmitter uses cURL to POST JSON to configurable endpoint
- DaemonTransmitter checks circuit breaker before sending
- DaemonTransmitter records success/failure to circuit breaker
- All PHP files pass syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-03-SUMMARY.md`
</output>
