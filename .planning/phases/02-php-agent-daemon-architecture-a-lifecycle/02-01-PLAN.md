---
phase: 02-php-agent-daemon-architecture-a-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - php-agent/daemon/daemon.php
  - php-agent/daemon/socket_server.php
  - php-agent/daemon/worker_lifecycle.php
autonomous: true

must_haves:
  truths:
    - "Daemon starts and listens on Unix domain socket"
    - "Daemon receives profiling data from listener.php"
    - "Daemon monitors its own memory usage"
    - "Daemon tracks request count and restarts when threshold reached"
    - "Daemon runs garbage collection periodically"
    - "Daemon handles SIGTERM gracefully"
  artifacts:
    - path: "php-agent/daemon/daemon.php"
      provides: "Main daemon entry point with ReactPHP event loop"
      min_lines: 100
    - path: "php-agent/daemon/socket_server.php"
      provides: "Unix domain socket server component"
      exports: ["SocketServer"]
    - path: "php-agent/daemon/worker_lifecycle.php"
      provides: "Worker lifecycle management (memory, requests, GC)"
      exports: ["WorkerLifecycle"]
  key_links:
    - from: "php-agent/daemon/daemon.php"
      to: "php-agent/daemon/socket_server.php"
      via: "require_once and instantiation"
      pattern: "new SocketServer"
    - from: "php-agent/daemon/daemon.php"
      to: "php-agent/daemon/worker_lifecycle.php"
      via: "require_once and instantiation"
      pattern: "new WorkerLifecycle"
---

<objective>
Build the daemon foundation with ReactPHP event loop, Unix socket server, worker lifecycle management, signal handling, and garbage collection.

Purpose: The daemon is the core component that receives profiling data from PHP requests via Unix socket. This plan establishes the skeleton that subsequent plans will extend with buffering and circuit breaker logic.

Output:
- daemon.php - Main entry point with event loop
- socket_server.php - Unix socket server receiving profiling data
- worker_lifecycle.php - Memory/request threshold monitoring and GC
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-RESEARCH.md
@php-agent/profiling/transmitter.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkerLifecycle class for memory/request threshold management</name>
  <files>php-agent/daemon/worker_lifecycle.php</files>
  <action>
Create WorkerLifecycle class that monitors daemon health and triggers restart conditions.

Implementation:
1. Class properties:
   - $requestCount = 0 (tracks processed requests)
   - $maxRequests = 1000 (default, configurable in constructor)
   - $memoryLimit = 268435456 (256MB in bytes, configurable)
   - $gcInterval = 100 (run GC every N requests)
   - $lastGcRequestCount = 0

2. shouldRestart(): bool method
   - Check if $requestCount >= $maxRequests, log and return true
   - Check if memory_get_usage(true) > $memoryLimit, log and return true
   - Return false if neither threshold exceeded

3. incrementRequests(): void method
   - Increment $requestCount
   - If ($requestCount - $lastGcRequestCount) >= $gcInterval, call runGarbageCollection()

4. runGarbageCollection(): void method
   - Call gc_collect_cycles()
   - Update $lastGcRequestCount = $requestCount
   - Log memory usage after GC: error_log("BitvilleAPM: GC completed, memory: {MB}MB")

5. getStats(): array method
   - Return ['request_count', 'memory_usage_mb', 'memory_limit_mb', 'gc_runs']

Configuration via constructor:
```php
public function __construct(
    int $maxRequests = 1000,
    int $memoryLimitMb = 256,
    int $gcInterval = 100
)
```

All methods must be safe (no exceptions thrown).
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/worker_lifecycle.php
php -r "
require_once 'php-agent/daemon/worker_lifecycle.php';
\$wl = new WorkerLifecycle(1000, 256, 100);
echo 'Initial restart check: ' . (\$wl->shouldRestart() ? 'true' : 'false') . PHP_EOL;
for (\$i = 0; \$i < 50; \$i++) { \$wl->incrementRequests(); }
print_r(\$wl->getStats());
"
```
  </verify>
  <done>WorkerLifecycle class tracks request count, monitors memory, triggers GC every 100 requests, returns shouldRestart() = true when thresholds exceeded</done>
</task>

<task type="auto">
  <name>Task 2: Create SocketServer class for Unix domain socket reception</name>
  <files>php-agent/daemon/socket_server.php</files>
  <action>
Create SocketServer class using ReactPHP for async Unix domain socket server.

NOTE: Phase 1 transmitter.php uses SOCK_DGRAM (datagram) sockets. Per research, ReactPHP requires SOCK_STREAM. We need to update listener.php socket path in Plan 02-04 to use a different socket. For now, create a SOCK_STREAM server that can receive JSON data.

Implementation:
1. Class properties:
   - $socketPath (Unix socket path)
   - $server (React\Socket\UnixServer instance)
   - $onDataCallback (callable for received data)

2. Constructor:
   - Accept $socketPath (default: /var/run/bitville-apm/daemon.sock)
   - Accept $onDataCallback callable that will be called with parsed JSON data

3. start(): void method
   - Remove existing socket file if exists: if (file_exists($socketPath)) unlink($socketPath)
   - Create React\Socket\UnixServer on $socketPath
   - chmod($socketPath, 0666) for www-data access
   - Register 'connection' event handler:
     - On 'data' event: Parse JSON, call $onDataCallback with data array
     - Handle partial data accumulation (buffer until newline)
   - Log: error_log("BitvilleAPM: Socket server listening on {$socketPath}")

4. stop(): void method
   - Close server
   - Remove socket file: @unlink($socketPath)
   - Log: error_log("BitvilleAPM: Socket server stopped")

5. getSocketPath(): string method

Error handling:
- Wrap all operations in try-catch
- Log errors via error_log but don't throw
- If socket creation fails, log and set $server = null

NOTE: This plan does NOT add ReactPHP dependency yet (will be done in this task via composer require). Create the file assuming react/socket is available.

Before creating the class, run:
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/php-agent
composer init --name="bitville/php-agent" --type="library" --require="php:>=7.4" --no-interaction 2>/dev/null || true
composer require react/socket react/event-loop --no-interaction
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/socket_server.php
ls -la php-agent/vendor/react/socket
```
  </verify>
  <done>SocketServer class created with ReactPHP UnixServer, handles connections, parses JSON data, calls callback with parsed profiling data</done>
</task>

<task type="auto">
  <name>Task 3: Create main daemon.php entry point with event loop and signal handling</name>
  <files>php-agent/daemon/daemon.php</files>
  <action>
Create main daemon entry point that ties together socket server, worker lifecycle, and signal handling.

Implementation:
1. Shebang and strict mode:
```php
#!/usr/bin/env php
<?php
declare(strict_types=1);
```

2. Require dependencies:
```php
require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/socket_server.php';
require_once __DIR__ . '/worker_lifecycle.php';
```

3. Use statements:
```php
use React\EventLoop\Loop;
```

4. Configuration constants at top:
```php
define('DAEMON_SOCKET_PATH', '/var/run/bitville-apm/daemon.sock');
define('DAEMON_MEMORY_LIMIT_MB', 256);
define('DAEMON_MAX_REQUESTS', 1000);
define('DAEMON_GC_INTERVAL', 100);
```

5. Signal handling setup (BEFORE event loop):
```php
pcntl_async_signals(true);
$shouldShutdown = false;

pcntl_signal(SIGTERM, function() use (&$shouldShutdown) {
    error_log("BitvilleAPM: Received SIGTERM, initiating graceful shutdown...");
    $shouldShutdown = true;
});

pcntl_signal(SIGHUP, function() {
    error_log("BitvilleAPM: Received SIGHUP (reload not implemented yet)");
});
```

6. Create runtime directory if needed:
```php
$runtimeDir = dirname(DAEMON_SOCKET_PATH);
if (!is_dir($runtimeDir)) {
    @mkdir($runtimeDir, 0755, true);
}
```

7. Initialize WorkerLifecycle:
```php
$workerLifecycle = new WorkerLifecycle(
    DAEMON_MAX_REQUESTS,
    DAEMON_MEMORY_LIMIT_MB,
    DAEMON_GC_INTERVAL
);
```

8. Data handler callback (placeholder for now - will be extended in Plan 02-02):
```php
$onDataReceived = function(array $profilingData) use ($workerLifecycle) {
    $workerLifecycle->incrementRequests();

    // TODO: Plan 02-02 will add buffer management here
    // For now, just log receipt
    $correlationId = $profilingData['correlation_id'] ?? 'unknown';
    error_log("BitvilleAPM: Received profiling data for request {$correlationId}");
};
```

9. Initialize SocketServer:
```php
$socketServer = new SocketServer(DAEMON_SOCKET_PATH, $onDataReceived);
$socketServer->start();
```

10. Periodic timers:
```php
// Check for graceful shutdown every 1 second
Loop::addPeriodicTimer(1.0, function() use (&$shouldShutdown, $socketServer, $workerLifecycle) {
    if ($shouldShutdown) {
        error_log("BitvilleAPM: Shutting down...");
        // TODO: Plan 02-02 will flush buffers here
        $socketServer->stop();
        Loop::stop();
        return;
    }

    // Check if worker should restart (memory/request limits)
    if ($workerLifecycle->shouldRestart()) {
        error_log("BitvilleAPM: Worker restart triggered, exiting for supervisor to restart...");
        $socketServer->stop();
        Loop::stop();
        exit(0); // Clean exit, supervisor will restart
    }
});

// Log stats every 60 seconds
Loop::addPeriodicTimer(60.0, function() use ($workerLifecycle) {
    $stats = $workerLifecycle->getStats();
    error_log(sprintf(
        "BitvilleAPM: Stats - requests: %d, memory: %.1fMB, gc_runs: %d",
        $stats['request_count'],
        $stats['memory_usage_mb'],
        $stats['gc_runs']
    ));
});
```

11. Startup message and run:
```php
error_log("BitvilleAPM: Daemon starting...");
error_log(sprintf(
    "BitvilleAPM: Config - socket: %s, memory_limit: %dMB, max_requests: %d",
    DAEMON_SOCKET_PATH,
    DAEMON_MEMORY_LIMIT_MB,
    DAEMON_MAX_REQUESTS
));

Loop::run();

error_log("BitvilleAPM: Daemon stopped");
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/daemon.php

# Test that daemon can start (will fail on socket dir permissions, but syntax should pass)
timeout 2 php php-agent/daemon/daemon.php 2>&1 || echo "Daemon exited (expected - no socket dir permissions)"
```
  </verify>
  <done>daemon.php entry point with ReactPHP event loop, SIGTERM/SIGHUP handlers, worker lifecycle monitoring, periodic stats logging, graceful shutdown flow</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Syntax validation:
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring
php -l php-agent/daemon/worker_lifecycle.php
php -l php-agent/daemon/socket_server.php
php -l php-agent/daemon/daemon.php
```

2. WorkerLifecycle unit test:
```bash
php -r "
require_once 'php-agent/daemon/worker_lifecycle.php';
\$wl = new WorkerLifecycle(100, 256, 10);
for (\$i = 0; \$i < 50; \$i++) { \$wl->incrementRequests(); }
echo 'After 50 requests: ';
print_r(\$wl->getStats());
echo 'Should restart (50/100): ' . (\$wl->shouldRestart() ? 'yes' : 'no') . PHP_EOL;
for (\$i = 0; \$i < 55; \$i++) { \$wl->incrementRequests(); }
echo 'Should restart (105/100): ' . (\$wl->shouldRestart() ? 'yes' : 'no') . PHP_EOL;
"
```

3. ReactPHP dependency installed:
```bash
ls php-agent/vendor/react/socket/src/UnixServer.php
```
</verification>

<success_criteria>
- WorkerLifecycle class monitors memory, tracks requests, runs GC
- SocketServer class wraps ReactPHP UnixServer with JSON parsing
- daemon.php ties everything together with event loop and signal handling
- SIGTERM triggers graceful shutdown
- Worker restarts when memory > 256MB or requests > 1000
- GC runs every 100 requests
- All PHP files pass syntax check
- ReactPHP react/socket and react/event-loop installed via Composer
</success_criteria>

<output>
After completion, create `.planning/phases/02-php-agent-daemon-architecture-a-lifecycle/02-01-SUMMARY.md`
</output>
