---
phase: 05-postgres-agent-database-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - postgres-agent/pyproject.toml
  - postgres-agent/requirements.txt
  - postgres-agent/src/__init__.py
  - postgres-agent/src/config.py
  - postgres-agent/src/database/__init__.py
  - postgres-agent/src/database/pool.py
  - postgres-agent/config/agent.ini.example
autonomous: true

must_haves:
  truths:
    - "Agent configuration can be loaded from INI file or environment variables"
    - "Database connection pool enforces statement timeout of 5 seconds"
    - "Connection pool is limited to max 5 connections"
    - "Agent can connect to Postgres server with pg_read_all_stats role"
  artifacts:
    - path: "postgres-agent/pyproject.toml"
      provides: "Python project definition with dependencies"
      contains: "psycopg"
    - path: "postgres-agent/src/config.py"
      provides: "Configuration loader with INI and env support"
      exports: ["Config", "load_config"]
    - path: "postgres-agent/src/database/pool.py"
      provides: "Connection pool with safety limits"
      exports: ["create_pool", "get_pool"]
  key_links:
    - from: "postgres-agent/src/database/pool.py"
      to: "Postgres server"
      via: "psycopg3 ConnectionPool with statement_timeout"
      pattern: "statement_timeout=5000"
---

<objective>
Create the Postgres agent Python project foundation with configuration system and safe database connection pooling.

Purpose: Establish the base structure for the monitoring agent with safety-first database access that cannot cause performance degradation on the DB server (PG-07).

Output: Working Python project that can connect to Postgres with enforced query timeouts and connection limits.
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-postgres-agent-database-monitoring/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python project structure with dependencies</name>
  <files>
    postgres-agent/pyproject.toml
    postgres-agent/requirements.txt
    postgres-agent/src/__init__.py
    postgres-agent/src/database/__init__.py
  </files>
  <action>
Create the Python project for the Postgres monitoring agent.

1. Create `postgres-agent/pyproject.toml` with:
   - Project name: bitville-postgres-agent
   - Python version: >=3.11
   - Dependencies: psycopg[binary,pool]>=3.1.0, psutil>=7.0.0, persist-queue>=1.0.0, requests>=2.31.0, pybreaker>=1.0.0, structlog>=24.0.0
   - Entry point: postgres_agent.main:main

2. Create `postgres-agent/requirements.txt` with pinned versions:
   ```
   psycopg[binary,pool]>=3.1.0
   psutil>=7.0.0
   persist-queue>=1.0.0
   requests>=2.31.0
   pybreaker>=1.0.0
   structlog>=24.0.0
   ```

3. Create empty `postgres-agent/src/__init__.py`

4. Create empty `postgres-agent/src/database/__init__.py`

Directory structure:
```
postgres-agent/
├── pyproject.toml
├── requirements.txt
├── src/
│   ├── __init__.py
│   └── database/
│       └── __init__.py
```
  </action>
  <verify>
    - File exists: postgres-agent/pyproject.toml
    - File exists: postgres-agent/requirements.txt
    - File exists: postgres-agent/src/__init__.py
    - File exists: postgres-agent/src/database/__init__.py
    - pyproject.toml contains psycopg[binary,pool]
  </verify>
  <done>Python project structure with all dependencies defined</done>
</task>

<task type="auto">
  <name>Task 2: Create configuration loader with safety defaults</name>
  <files>
    postgres-agent/src/config.py
    postgres-agent/config/agent.ini.example
  </files>
  <action>
Create configuration system supporting INI files and environment variables.

1. Create `postgres-agent/src/config.py`:
   ```python
   """
   Configuration loader for Postgres monitoring agent.

   Supports INI file and environment variable overrides.
   Safe defaults that prioritize database safety.
   """
   import os
   import configparser
   from dataclasses import dataclass
   from typing import Optional
   import structlog

   logger = structlog.get_logger()

   @dataclass
   class Config:
       """Agent configuration with safe defaults."""

       # Database connection
       db_host: str = "localhost"
       db_port: int = 5432
       db_name: str = "postgres"
       db_user: str = "bitville_monitor"
       db_password: str = ""

       # Connection pool safety limits (PG-07)
       pool_min_size: int = 2
       pool_max_size: int = 5  # Never exceed 5 connections
       statement_timeout_ms: int = 5000  # 5 second query timeout
       connection_timeout_s: int = 30  # Connection acquisition timeout

       # Collection intervals
       collection_interval_s: int = 60  # 1 minute (PG-01)

       # Listener configuration (PG-COMM-01)
       listener_url: str = "https://listener:8443/ingest/postgres"
       listener_api_key: str = ""
       listener_timeout_s: int = 5

       # Project identification (PG-COMM-03)
       project_id: str = "default"

       # Buffer configuration (PG-COMM-02)
       buffer_path: str = "/var/lib/bitville-postgres-agent/buffer"
       buffer_max_size_mb: int = 100

       # Log parsing
       postgres_log_path: str = "/var/log/postgresql/postgresql-main.log"

       # Circuit breaker
       circuit_breaker_fail_max: int = 5
       circuit_breaker_timeout_s: int = 60

   def load_config(config_path: Optional[str] = None) -> Config:
       """
       Load configuration from INI file and environment variables.

       Priority:
       1. Environment variables (highest)
       2. INI file
       3. Defaults (lowest)

       Environment variable format: BITVILLE_PG_<SETTING_NAME>
       Example: BITVILLE_PG_DB_HOST, BITVILLE_PG_LISTENER_URL
       """
       config = Config()

       # Load from INI file if provided
       if config_path and os.path.exists(config_path):
           parser = configparser.ConfigParser()
           parser.read(config_path)

           if parser.has_section('database'):
               config.db_host = parser.get('database', 'host', fallback=config.db_host)
               config.db_port = parser.getint('database', 'port', fallback=config.db_port)
               config.db_name = parser.get('database', 'name', fallback=config.db_name)
               config.db_user = parser.get('database', 'user', fallback=config.db_user)
               config.db_password = parser.get('database', 'password', fallback=config.db_password)
               config.statement_timeout_ms = parser.getint('database', 'statement_timeout_ms', fallback=config.statement_timeout_ms)

           if parser.has_section('collection'):
               config.collection_interval_s = parser.getint('collection', 'interval_s', fallback=config.collection_interval_s)
               config.postgres_log_path = parser.get('collection', 'log_path', fallback=config.postgres_log_path)

           if parser.has_section('listener'):
               config.listener_url = parser.get('listener', 'url', fallback=config.listener_url)
               config.listener_api_key = parser.get('listener', 'api_key', fallback=config.listener_api_key)
               config.project_id = parser.get('listener', 'project_id', fallback=config.project_id)

           if parser.has_section('buffer'):
               config.buffer_path = parser.get('buffer', 'path', fallback=config.buffer_path)
               config.buffer_max_size_mb = parser.getint('buffer', 'max_size_mb', fallback=config.buffer_max_size_mb)

           logger.info("config_loaded_from_file", path=config_path)

       # Override with environment variables (highest priority)
       env_mappings = {
           'BITVILLE_PG_DB_HOST': ('db_host', str),
           'BITVILLE_PG_DB_PORT': ('db_port', int),
           'BITVILLE_PG_DB_NAME': ('db_name', str),
           'BITVILLE_PG_DB_USER': ('db_user', str),
           'BITVILLE_PG_DB_PASSWORD': ('db_password', str),
           'BITVILLE_PG_STATEMENT_TIMEOUT_MS': ('statement_timeout_ms', int),
           'BITVILLE_PG_COLLECTION_INTERVAL_S': ('collection_interval_s', int),
           'BITVILLE_PG_LISTENER_URL': ('listener_url', str),
           'BITVILLE_PG_LISTENER_API_KEY': ('listener_api_key', str),
           'BITVILLE_PG_PROJECT_ID': ('project_id', str),
           'BITVILLE_PG_BUFFER_PATH': ('buffer_path', str),
           'BITVILLE_PG_LOG_PATH': ('postgres_log_path', str),
       }

       for env_var, (attr, type_fn) in env_mappings.items():
           value = os.environ.get(env_var)
           if value is not None:
               setattr(config, attr, type_fn(value))
               logger.debug("config_override_from_env", var=env_var)

       # Enforce safety limits - pool_max_size MUST NOT exceed 5
       if config.pool_max_size > 5:
           logger.warning("pool_max_size_capped", requested=config.pool_max_size, capped=5)
           config.pool_max_size = 5

       # Enforce statement timeout minimum of 1 second
       if config.statement_timeout_ms < 1000:
           logger.warning("statement_timeout_increased", requested=config.statement_timeout_ms, minimum=1000)
           config.statement_timeout_ms = 1000

       return config
   ```

2. Create `postgres-agent/config/agent.ini.example`:
   ```ini
   # Bitville PostgreSQL Monitoring Agent Configuration
   # Copy to /etc/bitville/postgres-agent.ini and customize

   [database]
   # PostgreSQL connection settings
   host = 5.9.121.222
   port = 5432
   name = postgres
   user = bitville_monitor
   password = <your-password-here>

   # Query safety limit (milliseconds) - prevents hung queries
   statement_timeout_ms = 5000

   [collection]
   # Collection interval in seconds (default: 60 = 1 minute)
   interval_s = 60

   # PostgreSQL log file path for continuous parsing
   log_path = /var/log/postgresql/postgresql-main.log

   [listener]
   # Central listener server URL
   url = https://88.198.22.206:8443/ingest/postgres

   # API key for authentication (Bearer token)
   api_key = <your-api-key-here>

   # Project identifier included with all data
   project_id = bitville

   [buffer]
   # Local buffer path for offline resilience
   path = /var/lib/bitville-postgres-agent/buffer

   # Maximum buffer size in MB (oldest items evicted when exceeded)
   max_size_mb = 100
   ```
  </action>
  <verify>
    - File exists: postgres-agent/src/config.py
    - File exists: postgres-agent/config/agent.ini.example
    - config.py contains statement_timeout enforcement
    - config.py contains pool_max_size cap at 5
    - Example INI contains all configurable settings
  </verify>
  <done>Configuration system with INI/env support and enforced safety limits</done>
</task>

<task type="auto">
  <name>Task 3: Create connection pool with safety limits</name>
  <files>
    postgres-agent/src/database/pool.py
  </files>
  <action>
Create database connection pool with strict safety limits to prevent performance degradation (PG-07).

Create `postgres-agent/src/database/pool.py`:
```python
"""
PostgreSQL connection pool with safety limits.

Ensures monitoring queries cannot impact database performance:
- Statement timeout on all queries (5s default)
- Limited connection pool (max 5 connections)
- Connection acquisition timeout
- Graceful pool shutdown

PG-07: Never cause database failures or performance degradation
"""
from typing import Optional
from psycopg_pool import ConnectionPool
import structlog

from ..config import Config

logger = structlog.get_logger()

# Module-level pool instance
_pool: Optional[ConnectionPool] = None


def create_pool(config: Config) -> ConnectionPool:
    """
    Create connection pool with safety limits.

    Safety measures:
    1. statement_timeout in connection options (query timeout)
    2. Limited pool size (max 5 connections)
    3. Connection acquisition timeout
    4. Application name for identification in pg_stat_activity

    Args:
        config: Agent configuration

    Returns:
        ConnectionPool instance
    """
    global _pool

    # Build connection string
    conninfo = (
        f"host={config.db_host} "
        f"port={config.db_port} "
        f"dbname={config.db_name} "
        f"user={config.db_user} "
        f"password={config.db_password}"
    )

    # Safety: statement_timeout prevents hung queries
    # Safety: application_name identifies our connections in pg_stat_activity
    connection_kwargs = {
        "options": f"-c statement_timeout={config.statement_timeout_ms}",
        "application_name": "bitville-monitor"
    }

    logger.info(
        "creating_connection_pool",
        host=config.db_host,
        port=config.db_port,
        db=config.db_name,
        user=config.db_user,
        min_size=config.pool_min_size,
        max_size=config.pool_max_size,
        statement_timeout_ms=config.statement_timeout_ms
    )

    _pool = ConnectionPool(
        conninfo=conninfo,
        min_size=config.pool_min_size,
        max_size=config.pool_max_size,
        timeout=float(config.connection_timeout_s),
        kwargs=connection_kwargs,
        # Open pool immediately to verify connection
        open=True
    )

    # Test connection
    try:
        with _pool.connection() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
                result = cur.fetchone()
                if result and result[0] == 1:
                    logger.info("connection_pool_verified", status="healthy")
    except Exception as e:
        logger.error("connection_pool_test_failed", error=str(e))
        raise

    return _pool


def get_pool() -> ConnectionPool:
    """
    Get the current connection pool.

    Raises:
        RuntimeError: If pool not initialized (call create_pool first)

    Returns:
        ConnectionPool instance
    """
    if _pool is None:
        raise RuntimeError("Connection pool not initialized. Call create_pool() first.")
    return _pool


def close_pool() -> None:
    """
    Close the connection pool gracefully.

    Should be called during agent shutdown.
    """
    global _pool
    if _pool is not None:
        logger.info("closing_connection_pool")
        _pool.close()
        _pool = None


async def check_pool_health() -> dict:
    """
    Check connection pool health.

    Returns:
        Dict with pool statistics
    """
    if _pool is None:
        return {"status": "not_initialized"}

    try:
        stats = _pool.get_stats()
        return {
            "status": "healthy",
            "pool_size": stats.get("pool_size", 0),
            "pool_available": stats.get("pool_available", 0),
            "requests_waiting": stats.get("requests_waiting", 0),
            "connections_num": stats.get("connections_num", 0),
        }
    except Exception as e:
        return {"status": "error", "error": str(e)}
```
  </action>
  <verify>
    - File exists: postgres-agent/src/database/pool.py
    - Contains statement_timeout in connection kwargs
    - Contains pool_max_size limit
    - Contains application_name = "bitville-monitor"
    - Has create_pool, get_pool, close_pool functions
  </verify>
  <done>Connection pool with enforced safety limits (5s timeout, max 5 connections)</done>
</task>

</tasks>

<verification>
1. Project structure exists with all files
2. Configuration can be loaded from INI and environment variables
3. Pool max_size is capped at 5 regardless of configuration
4. Statement timeout is enforced at minimum 1000ms
5. Connection pool includes statement_timeout in options
</verification>

<success_criteria>
- Python project structure with dependencies defined
- Configuration loader with INI + env variable support
- Safety limits enforced: max 5 connections, minimum 1s query timeout
- Connection pool can connect to Postgres with timeout protection
</success_criteria>

<output>
After completion, create `.planning/phases/05-postgres-agent-database-monitoring/05-01-SUMMARY.md`
</output>
