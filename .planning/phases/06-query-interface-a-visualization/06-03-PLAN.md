---
phase: 06-query-interface
plan: 03
type: execute
wave: 2
depends_on:
  - "06-01"
  - "06-02"
files_modified:
  - listener/src/api/stats.ts
  - listener/src/api/correlation.ts
  - listener/src/database/stats-queries.ts
  - listener/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Stats API returns aggregate statistics for requests"
    - "Stats API returns percentile data (p50, p95, p99)"
    - "Correlation API returns all records linked by correlation ID"
    - "Comparative stats show request duration vs average for same URL"
  artifacts:
    - path: "listener/src/api/stats.ts"
      provides: "Statistics API handler"
      exports: ["handleGetStats", "handleGetComparison"]
    - path: "listener/src/api/correlation.ts"
      provides: "Correlation lookup API handler"
      exports: ["handleGetCorrelation"]
    - path: "listener/src/database/stats-queries.ts"
      provides: "Statistics aggregation queries"
      exports: ["getUrlStatistics", "getProjectStatistics", "getPercentiles"]
  key_links:
    - from: "listener/src/api/stats.ts"
      to: "listener/src/database/stats-queries.ts"
      via: "statistics query functions"
      pattern: "getUrlStatistics\\("
    - from: "listener/src/api/correlation.ts"
      to: "listener/src/database/queries.ts"
      via: "queryByCorrelationId function"
      pattern: "queryByCorrelationId\\("
---

<objective>
Create statistics and correlation APIs for comparative analysis and request linking (QUERY-04, QUERY-05).

Purpose: Enable viewing how a specific request compares to historical averages, and link PHP requests to their associated SQL queries via correlation ID.

Output:
- `/api/stats` endpoint for aggregate statistics and percentiles
- `/api/correlation/:id` endpoint for fetching linked records
- `/api/compare` endpoint for comparing request to averages
- Statistics queries with SQLite aggregate functions
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-query-interface-a-visualization/06-RESEARCH.md
@.planning/phases/06-query-interface-a-visualization/06-01-SUMMARY.md
@.planning/phases/06-query-interface-a-visualization/06-02-SUMMARY.md

# Existing codebase context
@listener/src/server.ts
@listener/src/database/queries.ts
@listener/src/database/search-queries.ts
@listener/src/api/search.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Statistics query functions</name>
  <files>
    listener/src/database/stats-queries.ts
  </files>
  <action>
Create `listener/src/database/stats-queries.ts` with:

1. `UrlStatistics` interface:
```typescript
export interface UrlStatistics {
  url: string;
  count: number;
  avg_duration: number;
  min_duration: number;
  max_duration: number;
  p50: number | null;
  p95: number | null;
  p99: number | null;
}
```

2. `getUrlStatistics(project: string, url: string): UrlStatistics | null` function:
   - Calculate aggregate stats for a specific URL pattern
   - Use SQLite aggregate functions: COUNT, AVG, MIN, MAX
   - For percentiles, try using SQLite's percentile() function first
   - If percentile() unavailable (compile-time flag), use manual calculation via subquery:

**Percentile calculation fallback (if built-in unavailable):**
```sql
-- P50 (median) calculation
SELECT duration_ms FROM (
  SELECT duration_ms, ROW_NUMBER() OVER (ORDER BY duration_ms) as rn,
         COUNT(*) OVER () as total
  FROM profiling_data
  WHERE project = ? AND url LIKE ? AND duration_ms IS NOT NULL
) WHERE rn = CAST(total * 0.5 AS INTEGER) + 1

-- Or simpler approach for Bun SQLite (which may lack window functions):
SELECT duration_ms FROM profiling_data
WHERE project = ? AND url LIKE ? AND duration_ms IS NOT NULL
ORDER BY duration_ms
LIMIT 1 OFFSET (
  SELECT CAST(COUNT(*) * 0.5 AS INTEGER)
  FROM profiling_data
  WHERE project = ? AND url LIKE ? AND duration_ms IS NOT NULL
)
```

3. `getProjectStatistics(project?: string): ProjectStatistics` function:
```typescript
export interface ProjectStatistics {
  total_records: number;
  total_php_requests: number;
  total_postgres_records: number;
  oldest_timestamp: number | null;
  newest_timestamp: number | null;
  avg_duration: number | null;
  by_source: Array<{ source: string; count: number }>;
}
```
   - Return overall project statistics
   - If project is omitted, return stats for all projects
   - Query:
```sql
SELECT
  COUNT(*) as total_records,
  SUM(CASE WHEN source = 'php_agent' THEN 1 ELSE 0 END) as total_php_requests,
  SUM(CASE WHEN source = 'postgres_agent' THEN 1 ELSE 0 END) as total_postgres_records,
  MIN(timestamp) as oldest_timestamp,
  MAX(timestamp) as newest_timestamp,
  AVG(duration_ms) as avg_duration
FROM profiling_data
WHERE project = ? OR ? IS NULL
```

4. `getComparisonData(correlationId: string): ComparisonData | null` function:
```typescript
export interface ComparisonData {
  request: {
    correlation_id: string;
    url: string;
    duration_ms: number;
    timestamp: number;
  };
  comparison: {
    avg_duration: number;
    percentile_rank: number;  // What percentile is this request in?
    faster_than_percent: number;
    sample_size: number;
  };
}
```
   - Fetch the request by correlation_id
   - Calculate how it compares to other requests with the same URL
   - Calculate percentile rank: what percent of requests were slower?
```sql
-- Count requests slower than this one
SELECT COUNT(*) as slower_count FROM profiling_data
WHERE url = ? AND duration_ms > ?

-- Total count for same URL
SELECT COUNT(*) as total_count FROM profiling_data
WHERE url = ? AND duration_ms IS NOT NULL
```

**Important:** All queries must use prepared statements and handle NULL values gracefully.
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/listener
bun -e "import { getProjectStatistics, getComparisonData } from './src/database/stats-queries.ts'; console.log('Imports OK')"
```
Should compile without errors.
  </verify>
  <done>
Statistics query functions calculate aggregates, percentiles, and comparison metrics. Percentile calculation works with or without SQLite percentile() extension.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stats and comparison API endpoints</name>
  <files>
    listener/src/api/stats.ts
  </files>
  <action>
Create `listener/src/api/stats.ts` with:

1. Zod schemas for request validation:
```typescript
import { z } from 'zod';

const StatsParamsSchema = z.object({
  project: z.string().optional(),
  url: z.string().optional(),
});

const CompareParamsSchema = z.object({
  correlation_id: z.string(),
});
```

2. `handleGetStats(req: Request): Response` function:
   - GET `/api/stats` - return overall statistics
   - GET `/api/stats?project=myapp` - return project-specific stats
   - GET `/api/stats?project=myapp&url=/api/users` - return URL-specific stats with percentiles

Response format for general stats:
```json
{
  "total_records": 1234,
  "total_php_requests": 1000,
  "total_postgres_records": 234,
  "oldest_timestamp": 1706400000,
  "newest_timestamp": 1706486400,
  "avg_duration": 523.5,
  "by_source": [
    { "source": "php_agent", "count": 1000 },
    { "source": "postgres_agent", "count": 234 }
  ]
}
```

Response format for URL-specific stats:
```json
{
  "url": "/api/users",
  "count": 150,
  "avg_duration": 245.3,
  "min_duration": 50,
  "max_duration": 1500,
  "p50": 200,
  "p95": 450,
  "p99": 890
}
```

3. `handleGetComparison(req: Request): Response` function:
   - GET `/api/compare?correlation_id=abc-123`
   - Return how this request compares to average

Response format:
```json
{
  "request": {
    "correlation_id": "abc-123",
    "url": "/api/users",
    "duration_ms": 750,
    "timestamp": 1706486400
  },
  "comparison": {
    "avg_duration": 245.3,
    "percentile_rank": 85,
    "faster_than_percent": 15,
    "sample_size": 150
  }
}
```
(This request is in the 85th percentile - slower than 85% of similar requests)

4. Error handling:
   - Return 400 for validation errors
   - Return 404 if correlation_id not found
   - Return 200 with empty/null values if no data available

Include CORS headers on all responses.
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/listener
bun -e "import { handleGetStats, handleGetComparison } from './src/api/stats.ts'; console.log('Imports OK')"
```
Should compile without errors.
  </verify>
  <done>
Stats API returns aggregate statistics. Comparison API shows how a request compares to historical averages for the same URL.
  </done>
</task>

<task type="auto">
  <name>Task 3: Correlation API endpoint</name>
  <files>
    listener/src/api/correlation.ts
    listener/src/server.ts
  </files>
  <action>
Create `listener/src/api/correlation.ts` with:

1. `handleGetCorrelation(req: Request): Response` function:
   - GET `/api/correlation/:id` - return all records with matching correlation_id
   - Use existing `queryByCorrelationId()` from queries.ts

Response format:
```json
{
  "correlation_id": "abc-123-def-456",
  "trace": {
    "php_request": {
      "id": 123,
      "project": "myapp",
      "timestamp": 1706486400,
      "duration_ms": 750,
      "payload": { ... }
    },
    "sql_queries": [
      {
        "id": 124,
        "project": "myapp",
        "timestamp": 1706486400,
        "source": "postgres_agent",
        "payload": { ... }
      }
    ]
  },
  "summary": {
    "total_records": 5,
    "php_count": 1,
    "postgres_count": 4,
    "total_sql_time_ms": 120
  }
}
```

2. Group records by source:
   - php_agent records go to `trace.php_request` (should be exactly 1)
   - postgres_agent records go to `trace.sql_queries` array

3. Calculate summary:
   - Count records by source
   - Sum SQL query times from postgres_agent payloads (if available)

4. Handle edge cases:
   - Return 404 if no records found for correlation_id
   - Handle multiple PHP requests (unusual but possible) - return as array

Modify `listener/src/server.ts` to add new API routes:

```typescript
// Import new handlers
import { handleGetStats, handleGetComparison } from "./api/stats.ts";
import { handleGetCorrelation } from "./api/correlation.ts";

// Add routes (before "Unknown route" catch-all):

// Stats API
if (req.method === "GET" && url.pathname === "/api/stats") {
  return handleGetStats(req);
}

// Comparison API
if (req.method === "GET" && url.pathname === "/api/compare") {
  return handleGetComparison(req);
}

// Correlation API (with path parameter)
if (req.method === "GET" && url.pathname.startsWith("/api/correlation/")) {
  const correlationId = url.pathname.replace("/api/correlation/", "");
  if (correlationId) {
    // Create a new URL with correlation_id as query param for consistent handling
    const newUrl = new URL(req.url);
    newUrl.searchParams.set("correlation_id", correlationId);
    return handleGetCorrelation(new Request(newUrl, req));
  }
}
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/listener

# Start server briefly
BITVILLE_DB_PATH=/tmp/test-api.db BITVILLE_API_KEY_TEST=test123 timeout 5 bun run src/server.ts &
sleep 2

# Test stats endpoint
curl -s "http://localhost:8443/api/stats" | head -c 200

# Test comparison endpoint (will return 404 - no data)
curl -s "http://localhost:8443/api/compare?correlation_id=test-123"

# Test correlation endpoint (will return 404 - no data)
curl -s "http://localhost:8443/api/correlation/test-123"

# Cleanup
pkill -f "bun run src/server.ts" 2>/dev/null || true
rm -f /tmp/test-api.db*
```
All endpoints respond (even if with empty data or 404).
  </verify>
  <done>
Correlation API returns all records linked by correlation_id, grouped into PHP request and SQL queries. Stats and comparison APIs return aggregate metrics.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Stats API responds:
```bash
curl "http://localhost:8443/api/stats"
curl "http://localhost:8443/api/stats?project=myapp"
```

2. Comparison API responds:
```bash
curl "http://localhost:8443/api/compare?correlation_id=abc-123"
```

3. Correlation API responds:
```bash
curl "http://localhost:8443/api/correlation/abc-123"
```

4. All endpoints return proper JSON with CORS headers
</verification>

<success_criteria>
1. `/api/stats` returns aggregate statistics (count, avg, min, max)
2. `/api/stats?url=X` returns URL-specific stats with percentiles
3. `/api/compare?correlation_id=X` shows how request compares to average
4. `/api/correlation/:id` returns grouped PHP + SQL records
5. Correlation endpoint links PHP requests to their SQL queries (QUERY-04)
6. Comparison data shows percentile rank (QUERY-05)
7. All endpoints include CORS headers
</success_criteria>

<output>
After completion, create `.planning/phases/06-query-interface-a-visualization/06-03-SUMMARY.md`
</output>
