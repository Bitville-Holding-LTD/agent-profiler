---
phase: 06-query-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - listener/src/api/search.ts
  - listener/src/database/search-queries.ts
  - listener/src/database/migrations.ts
  - listener/src/database/connection.ts
  - listener/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Search API returns profiling records filtered by project"
    - "Search API returns records filtered by URL pattern"
    - "Search API returns records filtered by duration range"
    - "Search API returns records filtered by timestamp range"
    - "Pagination uses cursor-based approach, not OFFSET"
  artifacts:
    - path: "listener/src/api/search.ts"
      provides: "Search API handler with Zod validation"
      exports: ["handleSearch", "SearchParamsSchema"]
    - path: "listener/src/database/search-queries.ts"
      provides: "Cursor-based pagination queries"
      exports: ["paginatedSearch", "getProjects"]
    - path: "listener/src/database/migrations.ts"
      provides: "Virtual column migration for URL indexing"
      exports: ["runMigrations"]
  key_links:
    - from: "listener/src/api/search.ts"
      to: "listener/src/database/search-queries.ts"
      via: "paginatedSearch function call"
      pattern: "paginatedSearch\\("
    - from: "listener/src/server.ts"
      to: "listener/src/api/search.ts"
      via: "route handler import"
      pattern: "handleSearch"
---

<objective>
Create the search/filter API for querying profiling data (QUERY-02, QUERY-06).

Purpose: Enable searching and filtering collected profiling data by project, URL, duration, and timestamp. This API is the foundation for the web UI to query and display data.

Output:
- `/api/search` endpoint with Zod-validated query parameters
- Cursor-based pagination for constant-time queries
- Virtual column + index for URL filtering (JSON extraction optimization)
- Project list endpoint for multi-project filtering
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-query-interface-a-visualization/06-RESEARCH.md

# Existing codebase context
@listener/src/server.ts
@listener/src/database/connection.ts
@listener/src/database/queries.ts
@listener/src/database/schema.sql
@listener/src/types/payloads.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migrations and virtual columns</name>
  <files>
    listener/src/database/migrations.ts
    listener/src/database/connection.ts
  </files>
  <action>
Create `listener/src/database/migrations.ts` with:

1. Migration registry pattern:
```typescript
interface Migration {
  id: string;
  up: (db: Database) => void;
}
```

2. `runMigrations(db: Database)` function that:
   - Creates migrations tracking table if not exists: `CREATE TABLE IF NOT EXISTS _migrations (id TEXT PRIMARY KEY, applied_at INTEGER)`
   - Checks which migrations have been applied
   - Runs pending migrations in order
   - Records each migration after successful execution

3. Add migration `001_url_virtual_column`:
   - Add virtual column: `ALTER TABLE profiling_data ADD COLUMN url TEXT GENERATED ALWAYS AS (json_extract(payload, '$.request.uri')) VIRTUAL`
   - Create index: `CREATE INDEX IF NOT EXISTS idx_url ON profiling_data(url)`
   - Handle "column already exists" error gracefully (SQLITE_ERROR with "duplicate column name")

4. Add migration `002_url_method_columns`:
   - Add virtual column for HTTP method: `ALTER TABLE profiling_data ADD COLUMN http_method TEXT GENERATED ALWAYS AS (json_extract(payload, '$.request.method')) VIRTUAL`
   - Add virtual column for status code: `ALTER TABLE profiling_data ADD COLUMN status_code INTEGER GENERATED ALWAYS AS (json_extract(payload, '$.response.status_code')) VIRTUAL`

Modify `listener/src/database/connection.ts`:
- Import and call `runMigrations(db)` after schema creation but before returning database instance
- Log migration execution: `console.log("[Database] Running migrations...")`

**Important:** Virtual columns are computed on read, not stored. They add ~0 storage overhead but enable index creation on JSON fields.
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/listener
bun run src/database/connection.ts 2>&1 | grep -E "(Migration|Running|applied)"
```
Should see migration messages. No errors about duplicate columns on subsequent runs.
  </verify>
  <done>
Migrations table tracks applied migrations. Virtual columns (url, http_method, status_code) exist and are indexed. Migrations are idempotent (safe to run multiple times).
  </done>
</task>

<task type="auto">
  <name>Task 2: Search queries with cursor-based pagination</name>
  <files>
    listener/src/database/search-queries.ts
  </files>
  <action>
Create `listener/src/database/search-queries.ts` with:

1. `SearchParams` interface:
```typescript
export interface SearchParams {
  project?: string;
  source?: 'php_agent' | 'postgres_agent';
  correlation_id?: string;
  url?: string;           // Uses virtual column, supports LIKE patterns
  duration_min?: number;  // Minimum duration in ms
  duration_max?: number;  // Maximum duration in ms
  timestamp_start?: number;  // Unix timestamp
  timestamp_end?: number;    // Unix timestamp
  after?: number;         // Cursor: timestamp to start after
  limit?: number;         // Default 50, max 100
}

export interface SearchResult {
  items: ProfilingDataRow[];
  cursor: number | null;  // Next timestamp cursor, null if no more results
  total_estimate?: number; // Approximate total matching records
}
```

2. `paginatedSearch(params: SearchParams): SearchResult` function:
   - Build query dynamically based on provided filters
   - Use cursor-based pagination: `WHERE timestamp < ? ORDER BY timestamp DESC LIMIT ?`
   - Fetch limit+1 rows to detect "has more"
   - Return cursor as timestamp of last item if more results exist
   - Use parameterized queries for all filters (SQL injection protection)

Query building pattern (not string concatenation):
```typescript
const conditions: string[] = ['1=1'];
const bindings: (string | number)[] = [];

if (params.project) {
  conditions.push('project = ?');
  bindings.push(params.project);
}
if (params.url) {
  conditions.push('url LIKE ?');
  bindings.push(params.url.includes('%') ? params.url : `%${params.url}%`);
}
// etc...

if (params.after) {
  conditions.push('timestamp < ?');
  bindings.push(params.after);
}

const query = `
  SELECT id, correlation_id, project, source, timestamp, duration_ms, payload, created_at, url, http_method, status_code
  FROM profiling_data
  WHERE ${conditions.join(' AND ')}
  ORDER BY timestamp DESC
  LIMIT ?
`;
bindings.push((params.limit || 50) + 1);
```

3. `getProjects(): string[]` function:
   - Return list of unique project names
   - Query: `SELECT DISTINCT project FROM profiling_data ORDER BY project`
   - Used for project filter dropdown in UI

4. `getStatistics(project?: string): object` function:
   - Return aggregate stats: total_records, oldest_timestamp, newest_timestamp
   - Optionally filter by project
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/listener
bun -e "import { paginatedSearch, getProjects } from './src/database/search-queries.ts'; console.log('Imports OK')"
```
Should compile without errors.
  </verify>
  <done>
`paginatedSearch` returns cursor-based paginated results. `getProjects` returns unique project list. Queries use indexes on virtual columns for URL filtering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Search API endpoint with Zod validation</name>
  <files>
    listener/src/api/search.ts
    listener/src/server.ts
  </files>
  <action>
Create `listener/src/api/search.ts` with:

1. Zod schema for query parameter validation:
```typescript
import { z } from 'zod';

export const SearchParamsSchema = z.object({
  project: z.string().optional(),
  source: z.enum(['php_agent', 'postgres_agent']).optional(),
  correlation_id: z.string().optional(),
  url: z.string().optional(),
  duration_min: z.coerce.number().positive().optional(),
  duration_max: z.coerce.number().positive().optional(),
  timestamp_start: z.coerce.number().optional(),
  timestamp_end: z.coerce.number().optional(),
  after: z.coerce.number().optional(),  // Cursor for pagination
  limit: z.coerce.number().min(1).max(100).default(50),
});

export type SearchParamsType = z.infer<typeof SearchParamsSchema>;
```

2. `handleSearch(req: Request): Response` function:
   - Parse query parameters from URL
   - Validate with Zod schema
   - On validation error: return 400 with `{ error: "Validation failed", details: zodError.errors }`
   - On success: call `paginatedSearch()` and return JSON response
   - Include CORS headers for local development: `Access-Control-Allow-Origin: *`

Response format:
```json
{
  "items": [...],
  "cursor": 1706400000,
  "hasMore": true
}
```

3. `handleGetProjects(req: Request): Response` function:
   - Return list of projects: `{ projects: ["project1", "project2"] }`

Modify `listener/src/server.ts`:
- Import handlers: `import { handleSearch, handleGetProjects } from "./api/search.ts";`
- Add routes before the "Unknown route" catch-all:
```typescript
// Query API endpoints (Phase 6)
if (req.method === "GET" && url.pathname === "/api/search") {
  return handleSearch(req);
}
if (req.method === "GET" && url.pathname === "/api/projects") {
  return handleGetProjects(req);
}
```
- Add OPTIONS handler for CORS preflight:
```typescript
if (req.method === "OPTIONS") {
  return new Response(null, {
    status: 204,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    },
  });
}
```
  </action>
  <verify>
```bash
cd /Users/andrewvonhoesslin/public_html/galaxyprojects/bitville-monitoring/listener

# Start server in background
BITVILLE_DB_PATH=/tmp/test-search.db BITVILLE_API_KEY_TEST=test123 timeout 5 bun run src/server.ts &
sleep 2

# Test search endpoint
curl -s "http://localhost:8443/api/search?limit=10" | head -c 200

# Test projects endpoint
curl -s "http://localhost:8443/api/projects"

# Test validation error
curl -s "http://localhost:8443/api/search?limit=999" | grep -i error

# Cleanup
pkill -f "bun run src/server.ts" 2>/dev/null || true
rm -f /tmp/test-search.db*
```
Search returns empty items array (no data). Projects returns empty array. Invalid limit returns validation error.
  </verify>
  <done>
`/api/search` endpoint accepts query parameters, validates with Zod, returns cursor-based paginated results. `/api/projects` returns unique project list. CORS headers allow browser access.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database migrations apply cleanly:
```bash
BITVILLE_DB_PATH=/tmp/test.db bun run listener/src/database/connection.ts
```

2. Search API responds to queries:
```bash
curl "http://localhost:8443/api/search?project=myapp&limit=10"
curl "http://localhost:8443/api/projects"
```

3. Virtual columns are indexed (check with EXPLAIN):
```bash
sqlite3 /tmp/test.db "EXPLAIN QUERY PLAN SELECT * FROM profiling_data WHERE url LIKE '%api%'"
# Should show "USING INDEX idx_url"
```
</verification>

<success_criteria>
1. `/api/search` endpoint returns filtered profiling data with cursor-based pagination
2. Filtering works for: project, source, correlation_id, url, duration range, timestamp range
3. `/api/projects` endpoint returns list of unique projects
4. URL filtering uses indexed virtual column (not full table scan)
5. Pagination uses cursor (timestamp), not OFFSET
6. Zod validates query parameters and returns helpful error messages
</success_criteria>

<output>
After completion, create `.planning/phases/06-query-interface-a-visualization/06-01-SUMMARY.md`
</output>
