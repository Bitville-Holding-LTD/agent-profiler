---
phase: 01-php-agent-core-instrumentation-safety
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - /var/www/project/site/profiling/transmitter.php
autonomous: true

must_haves:
  truths:
    - "Data is sent to listener via Unix domain socket"
    - "Socket operations complete within 50ms or skip silently"
    - "Failed transmission falls back to disk buffer"
    - "Application never blocks waiting for transmission"
    - "Listener unreachability never causes request failure"
  artifacts:
    - path: "/var/www/project/site/profiling/transmitter.php"
      provides: "Non-blocking socket transmission with fallback"
      contains: "function send_profiling_data"
      min_lines: 80
  key_links:
    - from: "transmitter.php"
      to: "config.php"
      via: "listener_socket path from config"
      pattern: "listener_socket"
    - from: "transmitter.php"
      to: "listener.sock"
      via: "Unix domain SOCK_DGRAM socket"
      pattern: "SOCK_DGRAM"
---

<objective>
Create the socket transmission layer that sends profiling data to the listener daemon with strict 50ms timeout and disk buffer fallback.

Purpose: This is the critical safety layer that ensures profiling NEVER impacts application performance. Data transmission must be fire-and-forget with guaranteed time bounds.

Output:
- `/var/www/project/site/profiling/transmitter.php` - Socket transmitter with fallback
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-CONTEXT.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create socket transmitter with timeout</name>
  <files>/var/www/project/site/profiling/transmitter.php</files>
  <action>
Create `/var/www/project/site/profiling/transmitter.php` with:

```php
<?php
/**
 * Profiling Data Transmitter
 *
 * Sends profiling data to listener daemon via Unix domain socket
 * with strict 50ms timeout and disk buffer fallback
 *
 * CRITICAL: This code must NEVER block the request or throw errors
 */

require_once __DIR__ . '/config.php';

// Timeout in microseconds (50ms)
define('TRANSMIT_TIMEOUT_USEC', 50000);

// Max size for datagram (64KB is typical limit)
define('MAX_DATAGRAM_SIZE', 65507);
```

1. `send_profiling_data($data)` main function:
```php
/**
 * Send profiling data to listener daemon
 *
 * @param array $data Profiling data to send
 * @return bool True if sent to socket, false if fell back to disk
 */
function send_profiling_data(array $data): bool
{
    try {
        $config = get_profiling_config();
        $socketPath = $config['listener_socket'] ?? '/var/run/bitville-apm/listener.sock';

        // Add timestamp and version
        $data['_meta'] = [
            'timestamp' => microtime(true),
            'php_version' => PHP_VERSION,
            'transmitter_version' => '1.0',
        ];

        $json = json_encode($data, JSON_UNESCAPED_SLASHES | JSON_PARTIAL_OUTPUT_ON_ERROR);

        if ($json === false) {
            error_log("Profiler: JSON encode failed - " . json_last_error_msg());
            return false;
        }

        // Check size before attempting send
        if (strlen($json) > MAX_DATAGRAM_SIZE) {
            // Data too large, truncate or split
            return send_large_data($data, $socketPath);
        }

        return send_via_socket($json, $socketPath);
    } catch (\Throwable $e) {
        error_log("Profiler transmit error: " . $e->getMessage());
        return false;
    }
}
```

2. `send_via_socket($json, $socketPath)` internal function:
```php
/**
 * Send JSON data via Unix domain socket with timeout
 *
 * @param string $json JSON-encoded data
 * @param string $socketPath Path to Unix socket
 * @return bool True if sent, false if failed
 */
function send_via_socket(string $json, string $socketPath): bool
{
    $socket = null;

    try {
        // Create Unix datagram socket (fire-and-forget, no connection needed)
        $socket = @socket_create(AF_UNIX, SOCK_DGRAM, 0);

        if ($socket === false) {
            error_log("Profiler: socket_create failed - " . socket_strerror(socket_last_error()));
            return write_to_disk_buffer($json);
        }

        // Set 50ms send timeout at socket level
        $result = @socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, [
            'sec' => 0,
            'usec' => TRANSMIT_TIMEOUT_USEC
        ]);

        if ($result === false) {
            error_log("Profiler: socket_set_option failed");
            @socket_close($socket);
            return write_to_disk_buffer($json);
        }

        // Send data (fire-and-forget for SOCK_DGRAM)
        $startTime = microtime(true);
        $bytesSent = @socket_sendto($socket, $json, strlen($json), 0, $socketPath);
        $elapsed = (microtime(true) - $startTime) * 1000;

        @socket_close($socket);

        if ($bytesSent === false) {
            $error = socket_last_error();
            // Common errors: ECONNREFUSED (111), ENOENT (2)
            error_log("Profiler: socket_sendto failed - " . socket_strerror($error) . " (elapsed: {$elapsed}ms)");
            return write_to_disk_buffer($json);
        }

        // Log if close to timeout
        if ($elapsed > 40) {
            error_log("Profiler: Warning - socket_sendto took {$elapsed}ms");
        }

        return true;
    } catch (\Throwable $e) {
        error_log("Profiler socket error: " . $e->getMessage());
        if ($socket !== null) {
            @socket_close($socket);
        }
        return write_to_disk_buffer($json);
    }
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/transmitter.php`
2. Test with non-existent socket path (should fall back to disk gracefully)
3. Verify socket timeout is set correctly
  </verify>
  <done>
- send_profiling_data() accepts array and encodes to JSON
- Socket created with AF_UNIX, SOCK_DGRAM (fire-and-forget)
- SO_SNDTIMEO set to 50ms
- Socket failures fall back to disk buffer
- All errors suppressed and logged
  </done>
</task>

<task type="auto">
  <name>Task 2: Create disk buffer fallback</name>
  <files>/var/www/project/site/profiling/transmitter.php</files>
  <action>
Add to `/var/www/project/site/profiling/transmitter.php`:

1. `write_to_disk_buffer($json)` function:
```php
/**
 * Write profiling data to disk buffer when socket unavailable
 *
 * Files are written atomically using tempnam + rename
 * Listener daemon will pick up these files when it recovers
 *
 * @param string $json JSON-encoded profiling data
 * @return bool True if written successfully
 */
function write_to_disk_buffer(string $json): bool
{
    try {
        $bufferDir = get_buffer_directory();

        if ($bufferDir === null) {
            return false;
        }

        // Create temp file in same directory (for atomic rename)
        $tempFile = @tempnam($bufferDir, 'profiling_');

        if ($tempFile === false) {
            error_log("Profiler: tempnam failed in $bufferDir");
            return false;
        }

        // Write data with exclusive lock
        $result = @file_put_contents($tempFile, $json, LOCK_EX);

        if ($result === false) {
            error_log("Profiler: file_put_contents failed to $tempFile");
            @unlink($tempFile);
            return false;
        }

        // Generate unique filename with timestamp
        $timestamp = date('Ymd_His');
        $unique = substr(md5(uniqid('', true)), 0, 8);
        $finalPath = $bufferDir . "/profile_{$timestamp}_{$unique}.json";

        // Atomic rename (same filesystem)
        if (!@rename($tempFile, $finalPath)) {
            error_log("Profiler: rename failed from $tempFile to $finalPath");
            @unlink($tempFile);
            return false;
        }

        return true;
    } catch (\Throwable $e) {
        error_log("Profiler disk buffer error: " . $e->getMessage());
        return false;
    }
}
```

2. `get_buffer_directory()` function:
```php
/**
 * Get writable buffer directory
 *
 * @return string|null Directory path or null if unavailable
 */
function get_buffer_directory(): ?string
{
    $candidates = [
        '/var/lib/bitville-apm/buffer',
        '/tmp/bitville-apm-buffer',
        sys_get_temp_dir() . '/bitville-apm-buffer',
    ];

    foreach ($candidates as $dir) {
        // Check if exists or can be created
        if (@is_dir($dir) && @is_writable($dir)) {
            return $dir;
        }

        // Try to create
        if (@mkdir($dir, 0755, true)) {
            return $dir;
        }
    }

    // Fall back to system temp dir directly
    $tempDir = sys_get_temp_dir();
    if (@is_writable($tempDir)) {
        return $tempDir;
    }

    error_log("Profiler: No writable buffer directory found");
    return null;
}
```

3. `cleanup_old_buffers($maxAge = 3600)` function:
```php
/**
 * Clean up buffer files older than maxAge seconds
 *
 * Should be called occasionally (e.g., in listener.php startup)
 *
 * @param int $maxAge Maximum age in seconds (default 1 hour)
 */
function cleanup_old_buffers(int $maxAge = 3600): void
{
    try {
        $bufferDir = get_buffer_directory();
        if ($bufferDir === null) {
            return;
        }

        $files = @glob($bufferDir . '/profile_*.json');
        if ($files === false) {
            return;
        }

        $now = time();
        foreach ($files as $file) {
            $mtime = @filemtime($file);
            if ($mtime !== false && ($now - $mtime) > $maxAge) {
                @unlink($file);
            }
        }
    } catch (\Throwable $e) {
        error_log("Profiler cleanup error: " . $e->getMessage());
    }
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/transmitter.php`
2. Test disk buffer write:
   ```php
   $result = write_to_disk_buffer('{"test": true}');
   echo $result ? "Written" : "Failed";
   ```
3. Verify atomic write pattern (temp file then rename)
4. Test cleanup function with mock old files
  </verify>
  <done>
- Disk buffer writes use atomic tempnam + rename pattern
- Multiple fallback directories tried
- Old buffer files cleaned up automatically
- All errors logged, never thrown
  </done>
</task>

<task type="auto">
  <name>Task 3: Add large data handling and helper functions</name>
  <files>/var/www/project/site/profiling/transmitter.php</files>
  <action>
Add to `/var/www/project/site/profiling/transmitter.php`:

1. `send_large_data($data, $socketPath)` function:
```php
/**
 * Handle large profiling data that exceeds datagram size
 *
 * Strategy: Truncate XHProf data (keep summary) and full SQL list
 * If still too large, write to disk buffer
 *
 * @param array $data Profiling data
 * @param string $socketPath Unix socket path
 * @return bool True if sent
 */
function send_large_data(array $data, string $socketPath): bool
{
    try {
        // First attempt: Truncate XHProf top_functions to top 50
        if (isset($data['xhprof']['profiling']['top_functions'])) {
            $data['xhprof']['profiling']['top_functions'] =
                array_slice($data['xhprof']['profiling']['top_functions'], 0, 50);
            $data['_meta']['truncated'] = true;
        }

        // Second attempt: Truncate SQL queries to top 100 slowest
        if (isset($data['sql']['queries']) && count($data['sql']['queries']) > 100) {
            // Sort by time descending
            usort($data['sql']['queries'], function($a, $b) {
                return ($b['time_ms'] ?? 0) <=> ($a['time_ms'] ?? 0);
            });
            $data['sql']['queries'] = array_slice($data['sql']['queries'], 0, 100);
            $data['_meta']['sql_truncated'] = true;
        }

        $json = json_encode($data, JSON_UNESCAPED_SLASHES | JSON_PARTIAL_OUTPUT_ON_ERROR);

        if (strlen($json) <= MAX_DATAGRAM_SIZE) {
            return send_via_socket($json, $socketPath);
        }

        // Still too large, go to disk buffer
        error_log("Profiler: Data still too large after truncation (" . strlen($json) . " bytes)");
        return write_to_disk_buffer($json);
    } catch (\Throwable $e) {
        error_log("Profiler large data error: " . $e->getMessage());
        return write_to_disk_buffer(json_encode($data));
    }
}
```

2. `transmit_or_buffer($data)` convenience function (alias):
```php
/**
 * Alias for send_profiling_data with clearer intent
 *
 * @param array $data Profiling data
 * @return bool True if transmitted via socket, false if buffered
 */
function transmit_or_buffer(array $data): bool
{
    return send_profiling_data($data);
}
```

3. `check_listener_socket()` diagnostic function:
```php
/**
 * Check if listener socket exists and is accessible
 *
 * For diagnostic purposes - not called in normal flow
 *
 * @return array Status info
 */
function check_listener_socket(): array
{
    $config = get_profiling_config();
    $socketPath = $config['listener_socket'] ?? '/var/run/bitville-apm/listener.sock';

    $status = [
        'socket_path' => $socketPath,
        'exists' => file_exists($socketPath),
        'is_socket' => false,
        'writable_dir' => is_writable(dirname($socketPath)),
    ];

    if ($status['exists']) {
        $stat = @stat($socketPath);
        $status['is_socket'] = ($stat !== false && ($stat['mode'] & 0140000) === 0140000);
    }

    return $status;
}
```

4. Constants and final cleanup - ensure file ends cleanly:
```php
// End of transmitter.php
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/transmitter.php`
2. Test large data truncation:
   ```php
   // Create large mock data
   $largeData = ['xhprof' => ['profiling' => ['top_functions' => range(1, 200)]]];
   // Should truncate to 50
   ```
3. Test check_listener_socket() diagnostic
  </verify>
  <done>
- Large data truncated intelligently (XHProf, SQL queries)
- transmit_or_buffer() alias available
- Diagnostic function for troubleshooting
- File complete and syntactically correct
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Socket transmission test (mock):**
```php
<?php
require_once '/var/www/project/site/profiling/transmitter.php';

$testData = [
    'correlation_id' => 'test-uuid-123',
    'elapsed_ms' => 750,
    'test' => true
];

// This will fail (no socket) and fall back to disk
$result = send_profiling_data($testData);
echo "Send result: " . ($result ? 'socket' : 'disk buffer') . "\n";
```

2. **Disk buffer test:**
```php
<?php
require_once '/var/www/project/site/profiling/transmitter.php';

$bufferDir = get_buffer_directory();
echo "Buffer directory: $bufferDir\n";
echo "Writable: " . (is_writable($bufferDir) ? 'yes' : 'no') . "\n";

// Write test file
$result = write_to_disk_buffer('{"test":"data"}');
echo "Write result: " . ($result ? 'success' : 'failed') . "\n";

// Check file exists
$files = glob($bufferDir . '/profile_*.json');
echo "Buffer files: " . count($files) . "\n";
```

3. **Socket diagnostic test:**
```php
<?php
require_once '/var/www/project/site/profiling/transmitter.php';

$status = check_listener_socket();
print_r($status);
// Will show socket_path, exists, is_socket, writable_dir
```

4. **Timeout behavior test:**
```php
<?php
require_once '/var/www/project/site/profiling/transmitter.php';

// This tests that even with non-existent socket, function returns quickly
$start = microtime(true);
for ($i = 0; $i < 10; $i++) {
    send_profiling_data(['test' => $i]);
}
$elapsed = (microtime(true) - $start) * 1000;
echo "10 sends took: {$elapsed}ms\n";
// Should be < 100ms total (each fails fast)
```
</verification>

<success_criteria>
Requirements covered:
- [x] COMM-01: Send profiling data to listener daemon within 50ms timeout
- [x] COMM-02: Use non-blocking sockets with SO_SNDTIMEO at socket level
- [x] COMM-03: Skip silently if listener unreachable (never cause request failure)

Measurable outcomes:
1. send_profiling_data() completes in <50ms even if socket unavailable
2. SO_SNDTIMEO set to 50000 microseconds (50ms)
3. Socket failures fall back to disk buffer
4. Disk buffer uses atomic writes (tempnam + rename)
5. No exceptions thrown, only logged
6. Large data (>64KB) truncated and sent or buffered
</success_criteria>

<output>
After completion, create `.planning/phases/01-php-agent-core-instrumentation-safety/01-04-SUMMARY.md`
</output>
