---
phase: 01-php-agent-core-instrumentation-safety
plan: 05
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - /var/www/project/site/profiling/request_collector.php
autonomous: true

must_haves:
  truths:
    - "Request URL and HTTP method are captured"
    - "Response time is calculated accurately"
    - "Request headers are captured (with sensitive filtering)"
    - "GET and POST variables are captured (with sensitive filtering)"
  artifacts:
    - path: "/var/www/project/site/profiling/request_collector.php"
      provides: "Request metadata collection"
      contains: "function collect_request_metadata"
      min_lines: 60
  key_links:
    - from: "request_collector.php"
      to: "config.php"
      via: "request_metadata toggle"
      pattern: "request_metadata"
    - from: "request_collector.php"
      to: "$_SERVER, $_GET, $_POST"
      via: "PHP superglobals"
      pattern: "\\$_SERVER"
---

<objective>
Create the request metadata collector that captures URL, method, headers, and request variables with sensitive data filtering.

Purpose: Request metadata provides context for understanding which specific requests are slow and what inputs they received. Essential for reproducing and debugging slow request patterns.

Output:
- `/var/www/project/site/profiling/request_collector.php` - Request metadata collection functions
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-CONTEXT.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request metadata collector</name>
  <files>/var/www/project/site/profiling/request_collector.php</files>
  <action>
Create `/var/www/project/site/profiling/request_collector.php` with:

```php
<?php
/**
 * Request Metadata Collector
 *
 * Captures request information: URL, method, headers, GET/POST variables
 * Filters sensitive data (passwords, tokens, etc.)
 */

require_once __DIR__ . '/config.php';

// Keys to always redact in request data
define('SENSITIVE_KEYS', [
    'password', 'passwd', 'pwd', 'pass',
    'token', 'auth_token', 'access_token', 'refresh_token',
    'api_key', 'apikey', 'secret', 'private_key',
    'credit_card', 'card_number', 'cvv', 'cvc',
    'ssn', 'social_security',
]);

// Headers to always redact
define('SENSITIVE_HEADERS', [
    'HTTP_AUTHORIZATION',
    'HTTP_X_API_KEY',
    'HTTP_X_AUTH_TOKEN',
    'HTTP_COOKIE',
]);
```

1. `collect_request_metadata()` main function:
```php
/**
 * Collect all request metadata
 *
 * @return array Request information
 */
function collect_request_metadata(): array
{
    $config = get_profiling_config();

    // Check if request metadata capture is enabled
    if (!($config['request_metadata'] ?? true)) {
        return [
            'url' => $_SERVER['REQUEST_URI'] ?? 'unknown',
            'method' => $_SERVER['REQUEST_METHOD'] ?? 'unknown',
            '_metadata_disabled' => true,
        ];
    }

    try {
        return [
            'url' => get_request_url(),
            'method' => $_SERVER['REQUEST_METHOD'] ?? 'unknown',
            'headers' => collect_headers(),
            'get' => filter_sensitive_data($_GET ?? []),
            'post' => filter_sensitive_data($_POST ?? []),
            'server' => collect_server_info(),
            'timestamp' => microtime(true),
        ];
    } catch (\Throwable $e) {
        error_log("Request collector error: " . $e->getMessage());
        return [
            'url' => $_SERVER['REQUEST_URI'] ?? 'unknown',
            'method' => $_SERVER['REQUEST_METHOD'] ?? 'unknown',
            'error' => 'Collection failed',
        ];
    }
}
```

2. `get_request_url()` function:
```php
/**
 * Get full request URL
 *
 * @return string URL
 */
function get_request_url(): string
{
    $scheme = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https' : 'http';
    $host = $_SERVER['HTTP_HOST'] ?? $_SERVER['SERVER_NAME'] ?? 'localhost';
    $uri = $_SERVER['REQUEST_URI'] ?? '/';

    // Redact query string values that look sensitive
    $urlParts = parse_url($uri);
    if (isset($urlParts['query'])) {
        parse_str($urlParts['query'], $queryParams);
        $queryParams = filter_sensitive_data($queryParams);
        $uri = $urlParts['path'] . '?' . http_build_query($queryParams);
    }

    return $scheme . '://' . $host . $uri;
}
```

3. `collect_headers()` function:
```php
/**
 * Collect HTTP headers with sensitive filtering
 *
 * @return array Headers
 */
function collect_headers(): array
{
    $headers = [];

    foreach ($_SERVER as $key => $value) {
        if (strpos($key, 'HTTP_') === 0) {
            // Convert HTTP_USER_AGENT to User-Agent format
            $headerName = str_replace('_', '-', substr($key, 5));
            $headerName = ucwords(strtolower($headerName), '-');

            // Check if sensitive
            if (in_array($key, SENSITIVE_HEADERS)) {
                $headers[$headerName] = '[REDACTED]';
            } else {
                $headers[$headerName] = $value;
            }
        }
    }

    // Limit header value length
    foreach ($headers as $key => $value) {
        if (strlen($value) > 500) {
            $headers[$key] = substr($value, 0, 500) . '...[truncated]';
        }
    }

    return $headers;
}
```

4. `collect_server_info()` function:
```php
/**
 * Collect relevant server info
 *
 * @return array Server information
 */
function collect_server_info(): array
{
    return [
        'server_software' => $_SERVER['SERVER_SOFTWARE'] ?? 'unknown',
        'server_name' => $_SERVER['SERVER_NAME'] ?? 'unknown',
        'remote_addr' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
        'server_addr' => $_SERVER['SERVER_ADDR'] ?? 'unknown',
        'document_root' => $_SERVER['DOCUMENT_ROOT'] ?? 'unknown',
        'script_filename' => $_SERVER['SCRIPT_FILENAME'] ?? 'unknown',
        'php_self' => $_SERVER['PHP_SELF'] ?? 'unknown',
    ];
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/request_collector.php`
2. Test collection with mock $_SERVER, $_GET, $_POST
3. Verify sensitive headers are redacted
  </verify>
  <done>
- collect_request_metadata() returns complete request info
- URL includes protocol, host, and path
- Headers collected and formatted properly
- Server info captured
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sensitive data filtering</name>
  <files>/var/www/project/site/profiling/request_collector.php</files>
  <action>
Add to `/var/www/project/site/profiling/request_collector.php`:

1. `filter_sensitive_data($data, $depth = 0)` function:
```php
/**
 * Filter sensitive data from arrays recursively
 *
 * @param mixed $data Data to filter
 * @param int $depth Current recursion depth
 * @return mixed Filtered data
 */
function filter_sensitive_data($data, int $depth = 0): mixed
{
    // Prevent infinite recursion
    if ($depth > 5) {
        return '[MAX_DEPTH_EXCEEDED]';
    }

    if (!is_array($data)) {
        return $data;
    }

    $filtered = [];

    foreach ($data as $key => $value) {
        $lowercaseKey = strtolower((string)$key);

        // Check if key is sensitive
        $isSensitive = false;
        foreach (SENSITIVE_KEYS as $sensitiveKey) {
            if (strpos($lowercaseKey, $sensitiveKey) !== false) {
                $isSensitive = true;
                break;
            }
        }

        if ($isSensitive) {
            $filtered[$key] = '[REDACTED]';
        } elseif (is_array($value)) {
            $filtered[$key] = filter_sensitive_data($value, $depth + 1);
        } elseif (is_string($value) && strlen($value) > 1000) {
            // Truncate very long strings
            $filtered[$key] = substr($value, 0, 1000) . '...[truncated]';
        } else {
            $filtered[$key] = $value;
        }
    }

    return $filtered;
}
```

2. `mask_email($email)` helper function:
```php
/**
 * Mask email address for privacy
 *
 * @param string $email Email address
 * @return string Masked email (j***@example.com)
 */
function mask_email(string $email): string
{
    $parts = explode('@', $email);
    if (count($parts) !== 2) {
        return '[INVALID_EMAIL]';
    }

    $local = $parts[0];
    $domain = $parts[1];

    if (strlen($local) <= 1) {
        $maskedLocal = '*';
    } else {
        $maskedLocal = $local[0] . str_repeat('*', min(3, strlen($local) - 1));
    }

    return $maskedLocal . '@' . $domain;
}
```

3. `filter_file_uploads()` function for $_FILES:
```php
/**
 * Collect file upload info without actual file contents
 *
 * @return array File upload metadata
 */
function filter_file_uploads(): array
{
    if (empty($_FILES)) {
        return [];
    }

    $files = [];

    foreach ($_FILES as $key => $file) {
        if (is_array($file['name'])) {
            // Multiple files
            $files[$key] = [
                'count' => count($file['name']),
                'type' => 'multiple',
            ];
        } else {
            $files[$key] = [
                'name' => $file['name'],
                'type' => $file['type'],
                'size' => $file['size'],
                'error' => $file['error'],
                // Explicitly exclude tmp_name and file contents
            ];
        }
    }

    return $files;
}
```

4. Update `collect_request_metadata()` to include files:
```php
// Add to the return array in collect_request_metadata():
'files' => filter_file_uploads(),
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/request_collector.php`
2. Test filter_sensitive_data():
   ```php
   $data = ['password' => 'secret', 'username' => 'john', 'auth_token' => 'abc123'];
   $filtered = filter_sensitive_data($data);
   // password and auth_token should be [REDACTED]
   // username should be preserved
   ```
3. Test mask_email()
4. Test filter_file_uploads() with mock $_FILES
  </verify>
  <done>
- Sensitive keys (password, token, etc.) are redacted
- Recursive array filtering works up to depth 5
- Long strings truncated to prevent memory issues
- Email masking available
- File uploads captured without contents
  </done>
</task>

<task type="auto">
  <name>Task 3: Add timing capture and complete API</name>
  <files>/var/www/project/site/profiling/request_collector.php</files>
  <action>
Add to `/var/www/project/site/profiling/request_collector.php`:

1. `RequestTimer` class for precise timing:
```php
/**
 * Request timer for tracking elapsed time
 */
class RequestTimer
{
    private static $startTime = null;

    /**
     * Start timing (call at request start)
     */
    public static function start(): void
    {
        self::$startTime = microtime(true);
    }

    /**
     * Get elapsed time in milliseconds
     *
     * @return float Elapsed ms
     */
    public static function elapsed(): float
    {
        if (self::$startTime === null) {
            // Fallback to REQUEST_TIME_FLOAT if available
            self::$startTime = $_SERVER['REQUEST_TIME_FLOAT'] ?? microtime(true);
        }

        return (microtime(true) - self::$startTime) * 1000;
    }

    /**
     * Check if elapsed time exceeds threshold
     *
     * @param float $thresholdMs Threshold in milliseconds
     * @return bool True if exceeded
     */
    public static function exceeds(float $thresholdMs): bool
    {
        return self::elapsed() >= $thresholdMs;
    }

    /**
     * Get timing data
     *
     * @return array Timing information
     */
    public static function getData(): array
    {
        return [
            'start_time' => self::$startTime,
            'elapsed_ms' => self::elapsed(),
            'request_time_float' => $_SERVER['REQUEST_TIME_FLOAT'] ?? null,
        ];
    }
}
```

2. `collect_response_info()` function:
```php
/**
 * Collect response information (call at request end)
 *
 * @return array Response info
 */
function collect_response_info(): array
{
    return [
        'status_code' => http_response_code() ?: 200,
        'headers_sent' => headers_sent(),
        'output_buffering' => ob_get_level() > 0,
        'content_type' => null,  // Will be set from headers if available
    ];
}
```

3. `collect_all_request_data()` convenience function:
```php
/**
 * Collect complete request data package
 *
 * @return array All request metadata
 */
function collect_all_request_data(): array
{
    return [
        'request' => collect_request_metadata(),
        'response' => collect_response_info(),
        'timing' => RequestTimer::getData(),
    ];
}
```

4. Global helper for listener.php:
```php
/**
 * Initialize request timing
 * Call this at the very start of listener.php
 */
function init_request_timer(): void
{
    RequestTimer::start();
}

/**
 * Check if request exceeds profiling threshold
 *
 * @return bool True if should profile
 */
function should_profile(): bool
{
    $config = get_profiling_config();
    $threshold = $config['threshold_ms'] ?? 500;
    return RequestTimer::exceeds($threshold);
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/request_collector.php`
2. Test RequestTimer:
   ```php
   RequestTimer::start();
   usleep(100000);  // 100ms
   echo "Elapsed: " . RequestTimer::elapsed() . "ms\n";
   echo "Exceeds 50ms: " . (RequestTimer::exceeds(50) ? 'yes' : 'no') . "\n";
   ```
3. Test should_profile() with various thresholds
  </verify>
  <done>
- RequestTimer tracks elapsed time accurately
- should_profile() checks against configured threshold
- collect_all_request_data() returns complete package
- Response info captured (status code, etc.)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Full collection test:**
```php
<?php
// Simulate web request environment
$_SERVER['REQUEST_METHOD'] = 'POST';
$_SERVER['REQUEST_URI'] = '/api/users?search=john';
$_SERVER['HTTP_HOST'] = 'example.com';
$_SERVER['HTTP_USER_AGENT'] = 'Test/1.0';
$_SERVER['HTTP_AUTHORIZATION'] = 'Bearer secret-token';
$_GET = ['search' => 'john'];
$_POST = ['username' => 'john', 'password' => 'secret123'];

require_once '/var/www/project/site/profiling/request_collector.php';

init_request_timer();

// Simulate work
usleep(100000);  // 100ms

$data = collect_all_request_data();
print_r($data);

// Verify:
// - Authorization header is [REDACTED]
// - password in POST is [REDACTED]
// - username is preserved
```

2. **Timing test:**
```php
<?php
require_once '/var/www/project/site/profiling/request_collector.php';

init_request_timer();

// Check at various points
echo "Initial: " . RequestTimer::elapsed() . "ms\n";

usleep(250000);  // 250ms
echo "After 250ms sleep: " . RequestTimer::elapsed() . "ms\n";
echo "Should profile (500ms threshold): " . (should_profile() ? 'yes' : 'no') . "\n";

usleep(300000);  // Another 300ms (total ~550ms)
echo "After 550ms total: " . RequestTimer::elapsed() . "ms\n";
echo "Should profile (500ms threshold): " . (should_profile() ? 'yes' : 'no') . "\n";
```

3. **Sensitive data test:**
```php
<?php
require_once '/var/www/project/site/profiling/request_collector.php';

$testData = [
    'username' => 'john',
    'password' => 'secret',
    'data' => [
        'api_key' => 'abc123',
        'info' => 'safe value',
    ],
];

$filtered = filter_sensitive_data($testData);
print_r($filtered);
// password and api_key should be [REDACTED]
// username and info should be preserved
```
</verification>

<success_criteria>
Requirements covered:
- [x] PHP-04: Collect request metadata (URL, method, headers, GET/POST variables, response time)

Measurable outcomes:
1. collect_request_metadata() returns URL, method, headers, get, post, server
2. Sensitive headers (Authorization, Cookie) are redacted
3. Sensitive POST fields (password, token, etc.) are redacted
4. RequestTimer accurately tracks elapsed time
5. should_profile() correctly evaluates against threshold
6. All errors handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-php-agent-core-instrumentation-safety/01-05-SUMMARY.md`
</output>
