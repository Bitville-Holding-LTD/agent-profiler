---
phase: 01-php-agent-core-instrumentation-safety
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05"]
files_modified:
  - /var/www/project/site/profiling/listener.php
autonomous: false

must_haves:
  truths:
    - "Profiling is initialized when listener.php is included"
    - "Profiling data is sent at request end via shutdown function"
    - "Only requests exceeding threshold trigger data transmission"
    - "Any profiler error is logged but never breaks the application"
    - "Project identifier is included in all profiling data"
  artifacts:
    - path: "/var/www/project/site/profiling/listener.php"
      provides: "Main profiler entry point for PHP application integration"
      contains: "register_shutdown_function"
      min_lines: 100
  key_links:
    - from: "listener.php"
      to: "xhprof_collector.php"
      via: "xhprof_start() at request start"
      pattern: "xhprof_start"
    - from: "listener.php"
      to: "transmitter.php"
      via: "send_profiling_data() in shutdown"
      pattern: "send_profiling_data"
    - from: "listener.php"
      to: "sql_collector.php"
      via: "SqlCollector attachment to db service"
      pattern: "SqlCollector"
    - from: "listener.php"
      to: "request_collector.php"
      via: "RequestTimer for threshold check"
      pattern: "should_profile"
---

<objective>
Create the main listener.php entry point that orchestrates all profiling components and integrates with the PHP application.

Purpose: This is the file that gets included in index.php. It ties together config, correlation ID, XHProf, SQL capture, request metadata, and transmission into a cohesive profiling system that activates transparently on slow requests.

Output:
- `/var/www/project/site/profiling/listener.php` - Main profiler orchestration file
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-CONTEXT.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-RESEARCH.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-01-SUMMARY.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-02-SUMMARY.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-03-SUMMARY.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-04-SUMMARY.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create listener.php main orchestration file</name>
  <files>/var/www/project/site/profiling/listener.php</files>
  <action>
Create `/var/www/project/site/profiling/listener.php`:

```php
<?php
/**
 * Bitville APM Profiler - Main Entry Point
 *
 * Include this file in your index.php BEFORE Application->run():
 *
 *   require_once __DIR__ . '/profiling/listener.php';
 *
 * The profiler will:
 * 1. Start timing and XHProf at include time
 * 2. Register shutdown function to collect data
 * 3. Only transmit data if request exceeds threshold (default 500ms)
 * 4. Never throw exceptions or break the application
 *
 * Configuration: /etc/bitville-apm/profiling.ini
 *
 * @version 1.0.0
 */

// ============================================================================
// SAFETY: Wrap entire profiler in try-catch
// ============================================================================

try {

// ============================================================================
// REQUIRE DEPENDENCIES
// ============================================================================

$profilerDir = __DIR__;
require_once $profilerDir . '/config.php';
require_once $profilerDir . '/correlation.php';
require_once $profilerDir . '/xhprof_collector.php';
require_once $profilerDir . '/sql_collector.php';
require_once $profilerDir . '/request_collector.php';
require_once $profilerDir . '/transmitter.php';

// ============================================================================
// HARD-CODED PROJECT IDENTIFIER
// Change this for each deployment
// ============================================================================

define('BITVILLE_APM_PROJECT', 'myproject');

// ============================================================================
// INITIALIZATION
// ============================================================================

// Generate unique correlation ID for this request
$GLOBALS['__bitville_apm_correlation_id'] = generate_correlation_id();

// Start request timer
init_request_timer();

// Start XHProf profiling (if enabled and extension loaded)
xhprof_start();

// SQL collector will be attached when DI is available (see attach function below)
$GLOBALS['__bitville_apm_sql_collector'] = null;

// ============================================================================
// SQL COLLECTOR ATTACHMENT FUNCTION
// ============================================================================

/**
 * Attach SQL collector to Phalcon DI container
 *
 * Call this AFTER Phalcon DI is initialized but BEFORE any database queries:
 *
 *   if (function_exists('bitville_apm_attach_sql')) {
 *       bitville_apm_attach_sql($di);
 *   }
 *
 * @param \Phalcon\Di\DiInterface $di Phalcon DI container
 */
function bitville_apm_attach_sql($di): void
{
    try {
        $correlationId = $GLOBALS['__bitville_apm_correlation_id'] ?? null;
        if ($correlationId === null) {
            return;
        }

        $collector = create_sql_collector($di, $correlationId);
        $GLOBALS['__bitville_apm_sql_collector'] = $collector;
    } catch (\Throwable $e) {
        error_log("Bitville APM: SQL collector attachment failed - " . $e->getMessage());
    }
}

// ============================================================================
// SHUTDOWN FUNCTION - CORE PROFILING LOGIC
// ============================================================================

register_shutdown_function(function() {
    // Reset execution time limit for shutdown operations
    // This prevents the profiler from being killed mid-execution
    @set_time_limit(0);

    try {
        // Check if profiling should be sent (request exceeded threshold)
        if (!should_profile()) {
            // Request was fast, discard profiling data
            xhprof_stop();  // Stop XHProf even if not sending
            return;
        }

        // ====================================================================
        // COLLECT ALL PROFILING DATA
        // ====================================================================

        $correlationId = $GLOBALS['__bitville_apm_correlation_id'] ?? 'unknown';
        $sqlCollector = $GLOBALS['__bitville_apm_sql_collector'];

        // Get XHProf data
        $xhprofData = xhprof_collect_all();

        // Get SQL data
        $sqlData = null;
        if ($sqlCollector !== null) {
            $sqlData = $sqlCollector->collectAll();
        }

        // Get request/response metadata
        $requestData = collect_all_request_data();

        // ====================================================================
        // BUILD PROFILING PAYLOAD
        // ====================================================================

        $config = get_profiling_config();

        $payload = [
            'correlation_id' => $correlationId,
            'project' => BITVILLE_APM_PROJECT,
            'timestamp' => microtime(true),
            'elapsed_ms' => RequestTimer::elapsed(),
            'threshold_ms' => $config['threshold_ms'] ?? 500,

            'request' => $requestData['request'] ?? [],
            'response' => $requestData['response'] ?? [],
            'timing' => $requestData['timing'] ?? [],

            'xhprof' => $xhprofData,
            'sql' => $sqlData,

            'server' => [
                'hostname' => gethostname() ?: 'unknown',
                'php_version' => PHP_VERSION,
                'sapi' => PHP_SAPI,
            ],
        ];

        // ====================================================================
        // CHECK FOR FATAL ERRORS
        // ====================================================================

        $lastError = error_get_last();
        if ($lastError !== null) {
            $fatalTypes = [E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR];
            if (in_array($lastError['type'], $fatalTypes)) {
                $payload['fatal_error'] = [
                    'type' => $lastError['type'],
                    'message' => $lastError['message'],
                    'file' => $lastError['file'],
                    'line' => $lastError['line'],
                ];
            }
        }

        // ====================================================================
        // TRANSMIT DATA
        // ====================================================================

        send_profiling_data($payload);

    } catch (\Throwable $e) {
        // Log but never fail
        error_log("Bitville APM shutdown error: " . $e->getMessage());
    }
});

// ============================================================================
// END OF SAFETY TRY-CATCH
// ============================================================================

} catch (\Throwable $e) {
    // Profiler initialization failed completely
    // Log and continue - application must not be affected
    error_log("Bitville APM initialization failed: " . $e->getMessage());
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/listener.php`
2. Verify all require_once paths are correct
3. Verify shutdown function is registered
4. Verify entire file is wrapped in try-catch
  </verify>
  <done>
- listener.php created with all component integration
- Correlation ID generated at include time
- XHProf started at include time
- Shutdown function registered for end-of-request collection
- All code wrapped in try-catch for safety
  </done>
</task>

<task type="auto">
  <name>Task 2: Add helper functions and integration documentation</name>
  <files>/var/www/project/site/profiling/listener.php</files>
  <action>
Add to the end of `/var/www/project/site/profiling/listener.php` (before the final catch block):

```php
// ============================================================================
// HELPER FUNCTIONS FOR APPLICATION USE
// ============================================================================

/**
 * Get the correlation ID for this request
 *
 * Use this to add correlation ID to outgoing HTTP requests, logs, etc.
 *
 * @return string|null Correlation ID or null if profiler not initialized
 */
function bitville_apm_correlation_id(): ?string
{
    return $GLOBALS['__bitville_apm_correlation_id'] ?? null;
}

/**
 * Get SQL comment for correlation ID injection
 *
 * Prepend this to SQL queries for database-side tracing:
 *   $sql = bitville_apm_sql_comment() . $sql;
 *
 * @return string SQL comment or empty string
 */
function bitville_apm_sql_comment(): string
{
    $correlationId = bitville_apm_correlation_id();
    if ($correlationId === null) {
        return '';
    }
    return format_sql_comment($correlationId);
}

/**
 * Add custom data to profiling payload
 *
 * Call this to add application-specific context:
 *   bitville_apm_add_context('user_id', 12345);
 *   bitville_apm_add_context('action', 'checkout');
 *
 * @param string $key Context key
 * @param mixed $value Context value (must be JSON-serializable)
 */
function bitville_apm_add_context(string $key, $value): void
{
    if (!isset($GLOBALS['__bitville_apm_custom_context'])) {
        $GLOBALS['__bitville_apm_custom_context'] = [];
    }
    $GLOBALS['__bitville_apm_custom_context'][$key] = $value;
}

/**
 * Check if profiler is active
 *
 * @return bool True if profiler initialized successfully
 */
function bitville_apm_is_active(): bool
{
    return isset($GLOBALS['__bitville_apm_correlation_id']);
}
```

Also update the payload building section in the shutdown function to include custom context:

```php
// Add this after building $payload but before transmitting:
// Include custom context if any
if (!empty($GLOBALS['__bitville_apm_custom_context'])) {
    $payload['custom'] = $GLOBALS['__bitville_apm_custom_context'];
}
```

Create integration documentation as comments at the top of the file:

```php
/**
 * ============================================================================
 * INTEGRATION GUIDE
 * ============================================================================
 *
 * 1. Include listener.php in your index.php:
 *
 *    // In /var/www/project/site/public/index.php:
 *    require_once dirname(__DIR__) . '/profiling/listener.php';
 *
 *    // ... autoloader and bootstrap ...
 *
 *    try {
 *        $application = new Application($di);
 *
 *        // Attach SQL collector after DI is ready
 *        if (function_exists('bitville_apm_attach_sql')) {
 *            bitville_apm_attach_sql($di);
 *        }
 *
 *        echo $application->handle($_SERVER['REQUEST_URI'])->getContent();
 *    } catch (\Exception $e) {
 *        // handle error
 *    }
 *
 * 2. Update project identifier:
 *    Edit the BITVILLE_APM_PROJECT constant in this file for each deployment.
 *
 * 3. Configure profiling:
 *    Edit /etc/bitville-apm/profiling.ini to adjust thresholds and features.
 *
 * 4. Optional - Add custom context:
 *    bitville_apm_add_context('user_id', $user->id);
 *    bitville_apm_add_context('route', $router->getMatchedRoute()->getName());
 *
 * ============================================================================
 */
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/listener.php`
2. Verify helper functions work when profiler initialized
3. Verify helper functions return safe values when profiler not initialized
  </verify>
  <done>
- Helper functions added for application integration
- Custom context support added
- Integration documentation included as comments
- File remains syntactically correct
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify profiler integration with test application</name>
  <what-built>
Complete PHP profiler with:
- Configuration system (/etc/bitville-apm/profiling.ini)
- Correlation ID generation (UUID v4)
- XHProf integration (function-level timing)
- SQL query capture (Phalcon events)
- Request metadata collection (URL, headers, GET/POST)
- Socket transmission with 50ms timeout and disk buffer fallback
- listener.php orchestration file
  </what-built>
  <how-to-verify>
1. Create test environment (or use existing PHP 7.4 environment):
   ```bash
   mkdir -p /var/www/project/site/profiling
   mkdir -p /etc/bitville-apm
   ```

2. Copy all profiler files to test environment

3. Create simple test script to verify profiler loads:
   ```php
   <?php
   // test_profiler.php
   require_once '/var/www/project/site/profiling/listener.php';

   echo "Profiler active: " . (bitville_apm_is_active() ? 'YES' : 'NO') . "\n";
   echo "Correlation ID: " . bitville_apm_correlation_id() . "\n";

   // Simulate slow work
   usleep(600000);  // 600ms - should trigger profiling

   echo "Test complete\n";
   ```

4. Run test script:
   ```bash
   php test_profiler.php
   ```

5. Check error_log for any profiler errors

6. Verify disk buffer file was created (socket won't exist yet):
   ```bash
   ls -la /tmp/bitville-apm-buffer/ 2>/dev/null || ls -la /tmp/profile_*.json
   ```

7. If file exists, verify JSON structure:
   ```bash
   cat /tmp/profile_*.json | python3 -m json.tool | head -50
   ```

Expected outcomes:
- No PHP errors or warnings during test
- Correlation ID is 36 characters (UUID format)
- Disk buffer file created with valid JSON
- JSON includes: correlation_id, project, elapsed_ms, request, xhprof
  </how-to-verify>
  <resume-signal>Type "approved" if profiler loads and executes correctly, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete (and checkpoint approved):

1. **Full integration test:**
```php
<?php
// full_test.php
$_SERVER['REQUEST_METHOD'] = 'GET';
$_SERVER['REQUEST_URI'] = '/test/profiler';
$_SERVER['HTTP_HOST'] = 'test.example.com';

require_once '/var/www/project/site/profiling/listener.php';

echo "=== Profiler Test ===\n";
echo "Active: " . (bitville_apm_is_active() ? 'yes' : 'no') . "\n";
echo "Correlation ID: " . bitville_apm_correlation_id() . "\n";
echo "SQL Comment: " . bitville_apm_sql_comment() . "\n";

// Add custom context
bitville_apm_add_context('test_run', true);
bitville_apm_add_context('test_time', date('c'));

// Simulate work (over threshold)
echo "Simulating 600ms work...\n";
for ($i = 0; $i < 60; $i++) {
    usleep(10000);  // 10ms x 60 = 600ms
    $x = range(1, 1000);  // Some memory work
}

echo "Elapsed: " . RequestTimer::elapsed() . "ms\n";
echo "Should profile: " . (should_profile() ? 'yes' : 'no') . "\n";

echo "=== Test Complete ===\n";
// Shutdown function will run after this
```

2. **Error handling test:**
```php
<?php
// error_test.php
// Temporarily break config to test resilience
rename('/etc/bitville-apm/profiling.ini', '/etc/bitville-apm/profiling.ini.bak');
file_put_contents('/etc/bitville-apm/profiling.ini', 'invalid{{{ini');

require_once '/var/www/project/site/profiling/listener.php';

echo "Profiler loaded despite bad config: " . (bitville_apm_is_active() ? 'yes' : 'no') . "\n";

// Restore
rename('/etc/bitville-apm/profiling.ini.bak', '/etc/bitville-apm/profiling.ini');
```

3. **Verify requirement coverage:**
- [x] PHP-01: 500ms threshold check in should_profile()
- [x] PHP-02: UUID v4 in generate_correlation_id()
- [x] PHP-03: XHProf via xhprof_start() / xhprof_collect_all()
- [x] PHP-04: Request metadata via collect_request_metadata()
- [x] PHP-05: Memory via get_memory_stats()
- [x] PHP-06: SQL via SqlCollector
- [x] PHP-07: Config toggles via profiling.ini
- [x] PHP-08: Project ID via BITVILLE_APM_PROJECT constant
- [x] COMM-01: 50ms timeout via SO_SNDTIMEO
- [x] COMM-02: Non-blocking SOCK_DGRAM
- [x] COMM-03: Silent skip via disk buffer fallback
</verification>

<success_criteria>
Requirements covered:
- [x] PHP-01: Capture profiling data only for requests exceeding 500ms threshold
- [x] PHP-02: Generate unique correlation ID (UUID v4) at request start
- [x] PHP-03: Integrate XHProf for function-level timing breakdown
- [x] PHP-04: Collect request metadata (URL, method, headers, GET/POST variables, response time)
- [x] PHP-05: Collect memory usage per function (peak memory, allocations)
- [x] PHP-06: Capture all SQL queries executed during request with timing
- [x] PHP-07: Support configurable on/off toggles for each profiling feature via settings file
- [x] PHP-08: Inject project identifier (manual configuration in listener.php)
- [x] COMM-01: Send profiling data to listener daemon within 50ms timeout
- [x] COMM-02: Use non-blocking sockets with SO_SNDTIMEO at socket level
- [x] COMM-03: Skip silently if listener unreachable (never cause request failure)

Measurable outcomes:
1. listener.php loads without errors
2. All profiler components integrate correctly
3. Shutdown function collects and transmits data
4. Threshold check prevents transmission for fast requests
5. Error handling prevents any application impact
6. Human verification confirms integration works
</success_criteria>

<output>
After completion, create `.planning/phases/01-php-agent-core-instrumentation-safety/01-06-SUMMARY.md`
</output>
