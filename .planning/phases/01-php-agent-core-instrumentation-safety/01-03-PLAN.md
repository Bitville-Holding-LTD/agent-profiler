---
phase: 01-php-agent-core-instrumentation-safety
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - /var/www/project/site/profiling/sql_collector.php
autonomous: true

must_haves:
  truths:
    - "SQL queries are captured with timing information"
    - "Correlation ID is prepended to queries as SQL comment"
    - "Sensitive data in queries is redacted"
    - "Stack trace context is captured for each query"
    - "SQL capture fails gracefully without breaking application"
  artifacts:
    - path: "/var/www/project/site/profiling/sql_collector.php"
      provides: "Phalcon event-based SQL capture"
      contains: "class SqlCollector"
      min_lines: 100
  key_links:
    - from: "sql_collector.php"
      to: "correlation.php"
      via: "format_sql_comment() for query tagging"
      pattern: "format_sql_comment"
    - from: "sql_collector.php"
      to: "Phalcon Events Manager"
      via: "beforeQuery/afterQuery events"
      pattern: "attach.*db.*beforeQuery"
---

<objective>
Create the SQL capture module that hooks into Phalcon's database events to collect all queries with timing, correlation IDs, and redacted sensitive data.

Purpose: SQL queries are a primary source of slow requests. This module captures every query executed during a request with enough context to identify the calling code and correlate with database-side monitoring.

Output:
- `/var/www/project/site/profiling/sql_collector.php` - SQL event hooks and data collection
</objective>

<execution_context>
@/Users/andrewvonhoesslin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrewvonhoesslin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-CONTEXT.md
@.planning/phases/01-php-agent-core-instrumentation-safety/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL collector class with Phalcon event hooks</name>
  <files>/var/www/project/site/profiling/sql_collector.php</files>
  <action>
Create `/var/www/project/site/profiling/sql_collector.php` with:

1. `SqlCollector` class:
```php
<?php
/**
 * SQL Collector - Captures all SQL queries via Phalcon events
 *
 * Integrates with Phalcon's Events Manager to capture beforeQuery/afterQuery
 * Adds correlation ID as SQL comment prefix for database-side tracing
 */

require_once __DIR__ . '/config.php';
require_once __DIR__ . '/correlation.php';

class SqlCollector
{
    private $correlationId;
    private $queries = [];
    private $currentQuery = null;
    private $enabled = true;
    private $maxQueries = 500;  // Prevent memory explosion on query-heavy pages
    private $captureStackTrace = true;
    private $stackTraceLimit = 5;

    public function __construct(string $correlationId)
    {
        $this->correlationId = $correlationId;

        $config = get_profiling_config();
        $method = $config['sql_capture_method'] ?? 'phalcon';

        // Disable if config says none
        if ($method === 'none') {
            $this->enabled = false;
        }
    }
}
```

2. `attachToConnection($connection)` method:
   - Creates Phalcon Events Manager if not exists
   - Attaches beforeQuery and afterQuery listeners
   - Sets the events manager on connection
   - Wrap in try-catch, disable SQL capture if fails

```php
public function attachToConnection($connection): bool
{
    if (!$this->enabled) {
        return false;
    }

    try {
        $eventsManager = $connection->getEventsManager();
        if ($eventsManager === null) {
            $eventsManager = new \Phalcon\Events\Manager();
        }

        $collector = $this;

        $eventsManager->attach('db:beforeQuery', function($event, $connection) use ($collector) {
            $collector->onBeforeQuery($connection);
        });

        $eventsManager->attach('db:afterQuery', function($event, $connection) use ($collector) {
            $collector->onAfterQuery($connection);
        });

        $connection->setEventsManager($eventsManager);
        return true;
    } catch (\Throwable $e) {
        error_log("SqlCollector: Failed to attach - " . $e->getMessage());
        $this->enabled = false;
        return false;
    }
}
```

3. `onBeforeQuery($connection)` method:
   - Capture query start time
   - Get SQL statement
   - Store in currentQuery for afterQuery to complete
   - Capture stack trace (limited)

```php
public function onBeforeQuery($connection): void
{
    if (!$this->enabled || count($this->queries) >= $this->maxQueries) {
        return;
    }

    try {
        $this->currentQuery = [
            'start_time' => microtime(true),
            'sql' => $connection->getSQLStatement(),
            'variables' => $connection->getSQLVariables(),
        ];

        if ($this->captureStackTrace) {
            $this->currentQuery['stack'] = debug_backtrace(
                DEBUG_BACKTRACE_IGNORE_ARGS,
                $this->stackTraceLimit
            );
        }
    } catch (\Throwable $e) {
        error_log("SqlCollector beforeQuery error: " . $e->getMessage());
    }
}
```

4. `onAfterQuery($connection)` method:
   - Calculate elapsed time
   - Add to queries array
   - Reset currentQuery

```php
public function onAfterQuery($connection): void
{
    if (!$this->enabled || $this->currentQuery === null) {
        return;
    }

    try {
        $endTime = microtime(true);
        $elapsed = ($endTime - $this->currentQuery['start_time']) * 1000;  // ms

        $this->queries[] = [
            'sql' => $this->redactSensitiveData($this->currentQuery['sql']),
            'time_ms' => round($elapsed, 3),
            'variables_count' => is_array($this->currentQuery['variables'])
                ? count($this->currentQuery['variables'])
                : 0,
            'stack' => $this->currentQuery['stack'] ?? [],
            'correlation_id' => $this->correlationId,
        ];
    } catch (\Throwable $e) {
        error_log("SqlCollector afterQuery error: " . $e->getMessage());
    }

    $this->currentQuery = null;
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/sql_collector.php`
2. Test class instantiation without Phalcon:
   - Should not throw errors
   - Should create instance with enabled=true (assuming config allows)
3. Verify stack trace capture uses DEBUG_BACKTRACE_IGNORE_ARGS
  </verify>
  <done>
- SqlCollector class created with event hook methods
- beforeQuery captures start time and SQL
- afterQuery calculates elapsed time
- Stack trace captured with limit
- All methods wrapped in try-catch
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sensitive data redaction and query formatting</name>
  <files>/var/www/project/site/profiling/sql_collector.php</files>
  <action>
Add to `SqlCollector` class in `/var/www/project/site/profiling/sql_collector.php`:

1. `redactSensitiveData($sql)` private method:
```php
private function redactSensitiveData(string $sql): string
{
    try {
        $patterns = [
            // Password fields
            "/password\s*=\s*'[^']*'/i" => "password='[REDACTED]'",
            '/password\s*=\s*"[^"]*"/i' => 'password="[REDACTED]"',

            // Token patterns
            "/token\s*=\s*'[^']*'/i" => "token='[REDACTED]'",
            '/token\s*=\s*"[^"]*"/i' => 'token="[REDACTED]"',
            "/api[_-]?key\s*=\s*'[^']*'/i" => "api_key='[REDACTED]'",

            // Secret patterns
            "/secret\s*=\s*'[^']*'/i" => "secret='[REDACTED]'",

            // Auth tokens in WHERE clauses
            "/auth[_-]?token\s*=\s*'[^']*'/i" => "auth_token='[REDACTED]'",

            // Credit card patterns (simple 16-digit)
            '/\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b/' => '[CARD-REDACTED]',
        ];

        foreach ($patterns as $pattern => $replacement) {
            $sql = preg_replace($pattern, $replacement, $sql);
        }

        return $sql;
    } catch (\Throwable $e) {
        // If redaction fails, return placeholder
        error_log("SqlCollector redaction error: " . $e->getMessage());
        return '[SQL REDACTION FAILED]';
    }
}
```

2. `getCorrelationComment()` method:
```php
public function getCorrelationComment(): string
{
    return format_sql_comment($this->correlationId);
}
```

3. `getQueries()` method:
```php
public function getQueries(): array
{
    return $this->queries;
}
```

4. `getSummary()` method for quick stats:
```php
public function getSummary(): array
{
    $totalTime = 0;
    $slowQueries = [];
    $slowThreshold = 100;  // 100ms

    foreach ($this->queries as $query) {
        $totalTime += $query['time_ms'];
        if ($query['time_ms'] >= $slowThreshold) {
            $slowQueries[] = $query;
        }
    }

    return [
        'total_queries' => count($this->queries),
        'total_time_ms' => round($totalTime, 2),
        'slow_queries_count' => count($slowQueries),
        'queries_truncated' => count($this->queries) >= $this->maxQueries,
    ];
}
```

5. `collectAll()` method for final data package:
```php
public function collectAll(): array
{
    return [
        'summary' => $this->getSummary(),
        'queries' => $this->queries,
        'correlation_id' => $this->correlationId,
    ];
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/sql_collector.php`
2. Test redaction with sample queries:
   - "SELECT * FROM users WHERE password='secret123'" should become
     "SELECT * FROM users WHERE password='[REDACTED]'"
   - "INSERT INTO tokens (token) VALUES ('abc123')" should redact token
3. Test getSummary() with mock data
  </verify>
  <done>
- Sensitive data redaction works for password, token, secret patterns
- getQueries() returns collected query array
- getSummary() provides aggregate statistics
- collectAll() returns complete SQL capture package
  </done>
</task>

<task type="auto">
  <name>Task 3: Add connection info capture and static factory</name>
  <files>/var/www/project/site/profiling/sql_collector.php</files>
  <action>
Add to `SqlCollector` class:

1. Update `onAfterQuery` to capture connection info:
```php
// Inside onAfterQuery, add to the query array:
'connection' => $this->getConnectionInfo($connection),
```

2. Add `getConnectionInfo($connection)` private method:
```php
private function getConnectionInfo($connection): array
{
    try {
        $descriptor = $connection->getDescriptor();
        return [
            'host' => $descriptor['host'] ?? 'unknown',
            'dbname' => $descriptor['dbname'] ?? 'unknown',
            'port' => $descriptor['port'] ?? 5432,
        ];
    } catch (\Throwable $e) {
        return ['host' => 'unknown', 'dbname' => 'unknown', 'port' => 0];
    }
}
```

3. Add static factory method for convenience:
```php
/**
 * Create and attach collector to a Phalcon DI container's db service
 *
 * @param \Phalcon\Di\DiInterface $di
 * @param string $correlationId
 * @return SqlCollector|null
 */
public static function createAndAttach($di, string $correlationId): ?self
{
    try {
        $collector = new self($correlationId);

        // Check if db service exists
        if (!$di->has('db')) {
            error_log("SqlCollector: No 'db' service in DI container");
            return $collector;  // Return collector but not attached
        }

        $db = $di->getShared('db');
        $collector->attachToConnection($db);

        return $collector;
    } catch (\Throwable $e) {
        error_log("SqlCollector::createAndAttach failed: " . $e->getMessage());
        return null;
    }
}
```

4. Add method to check if capture is working:
```php
public function isEnabled(): bool
{
    return $this->enabled;
}

public function getCorrelationId(): string
{
    return $this->correlationId;
}
```

5. Add reset method for testing:
```php
public function reset(): void
{
    $this->queries = [];
    $this->currentQuery = null;
}
```

At the end of the file, add global helper function:
```php
/**
 * Global function to create SQL collector - called from listener.php
 */
function create_sql_collector($di, string $correlationId): ?SqlCollector
{
    return SqlCollector::createAndAttach($di, $correlationId);
}
```
  </action>
  <verify>
1. Syntax check: `php -l /var/www/project/site/profiling/sql_collector.php`
2. Verify static factory handles missing db service gracefully
3. Verify connection info capture doesn't throw on missing descriptor keys
  </verify>
  <done>
- Connection info (host, dbname, port) captured for each query
- Static factory creates and attaches collector
- Global helper function available for listener.php
- All edge cases handled with safe defaults
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **SQL Collector instantiation test:**
```php
<?php
require_once '/var/www/project/site/profiling/sql_collector.php';

$correlationId = generate_correlation_id();
$collector = new SqlCollector($correlationId);

echo "Enabled: " . ($collector->isEnabled() ? 'yes' : 'no') . "\n";
echo "Correlation ID: " . $collector->getCorrelationId() . "\n";
echo "Correlation comment: " . $collector->getCorrelationComment() . "\n";
```

2. **Redaction test:**
```php
<?php
require_once '/var/www/project/site/profiling/sql_collector.php';

// Test via reflection (redactSensitiveData is private)
$collector = new SqlCollector('test-uuid');
$reflection = new ReflectionClass($collector);
$method = $reflection->getMethod('redactSensitiveData');
$method->setAccessible(true);

$testCases = [
    "SELECT * FROM users WHERE password='secret123'" => "[REDACTED]",
    "UPDATE tokens SET token='abc' WHERE id=1" => "[REDACTED]",
    "SELECT * FROM orders WHERE total > 100" => "orders",  // Should NOT be redacted
];

foreach ($testCases as $sql => $expectContains) {
    $result = $method->invoke($collector, $sql);
    echo "Input: $sql\n";
    echo "Output: $result\n\n";
}
```

3. **Mock query collection test:**
```php
<?php
require_once '/var/www/project/site/profiling/sql_collector.php';

$collector = new SqlCollector('test-uuid');

// Manually add mock queries
$reflection = new ReflectionClass($collector);
$prop = $reflection->getProperty('queries');
$prop->setAccessible(true);
$prop->setValue($collector, [
    ['sql' => 'SELECT 1', 'time_ms' => 50, 'stack' => []],
    ['sql' => 'SELECT 2', 'time_ms' => 150, 'stack' => []],
]);

$summary = $collector->getSummary();
print_r($summary);
// Should show: total_queries=2, slow_queries_count=1
```
</verification>

<success_criteria>
Requirements covered:
- [x] PHP-06: Capture all SQL queries executed during request with timing

Measurable outcomes:
1. SqlCollector class instantiates without errors
2. Phalcon event attachment works (or fails gracefully)
3. Sensitive data redaction covers password, token, secret, card patterns
4. Stack traces limited to 5 frames with no arguments
5. Query count limited to 500 to prevent memory issues
6. getSummary() provides accurate aggregate stats
7. collectAll() returns complete SQL package
8. All errors logged, never thrown
</success_criteria>

<output>
After completion, create `.planning/phases/01-php-agent-core-instrumentation-safety/01-03-SUMMARY.md`
</output>
